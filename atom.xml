<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>duteliang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-30T15:25:49.568Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>duteliang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="http://yoursite.com/2019/12/30/zookeeper/"/>
    <id>http://yoursite.com/2019/12/30/zookeeper/</id>
    <published>2019-12-30T15:12:12.000Z</published>
    <updated>2019-12-30T15:25:49.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在现在分布式、微服务大行其道的今天，肯定都会接触ZooKeeper这个框架。本人也只是在Dubbo的项目中有使用过(当然Kafka的集群部署也是基于ZooKeeper,这个就不算使用了)。但是它可以做的事远不止在Dubbo中的使用。所以先了解了ZooKeeper的基本模型、概念以及使用，以便加深学习</p><h2 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h2><p>ZooKeeper 是一个开源的分布式协调服务,设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>ZooKeeper 是一个典型的分布式数据一致性解决方案。其主要应用场景：</p><ol><li>master节点选举，主节点挂了以后，从节点就会接收工作，并且节点是唯一的。保证高可用（比如Kafka集群）</li><li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他服务器。</li><li>发布与订阅。类似于消息队列MQ，dubbo发布者把数据发布到znode上，订阅者会拉出数据</li><li>分布式锁</li><li>集群管理，集群中保证数据的强一致性（Dubbo的注册中心）</li></ol><p>本人主要接触ZooKeeper还是在公司使用Dubbo的时候接触的，所以ZooKeeper主要是用于：服务的容错、负载均衡、查找服务和管理服务，还可以选择其作为配置中心的集中式管理。</p><h2 id="ZooKeeper的数据模型"><a href="#ZooKeeper的数据模型" class="headerlink" title="ZooKeeper的数据模型"></a>ZooKeeper的数据模型</h2><h3 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h3><p>在了解ZooKeeper的数据模型之前，有必要了解ZooKeeper的Session机制</p><p>Session是指客户端和服务端之间会话。在ZooKeeper中是指一个客户端与ZooKeeper之间的一次长连接。客户端在启动时会与服务端建立一个Tcp连接。后续客户端可已通过这个连接发送消息给服务端，也可以监听服务端发送来的消息。客户端和服务端有一个心跳机制来维持和判断这个连接的有效性，可以通过Session中的<code>sessionTimeout</code>值来设置一个客户端的超时时间。同时当由于服务器原因或者客户端主动要求端口连接的时候，只要在超时时间内重新连接任一一台ZooKeeper机器，那么之前创建的 Session仍然有效。</p><p>和我们平常接触到HttpSession一样，每次创建一次会话，服务端都会为该客户端分配一个SessionId，该SessionId也是全局唯一的。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>ZooKeeper的数据模型和我们经常使用的Unix/Linux的文件系统是类似的。</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/ZooKeeper-model-cbdsiaaaa2312y7r671f7f376ghucdvq793f271.jpg" alt="ZooKeepr的内存模型"></p><p>上图中我们可以比较明显看到和文件系统很像，实际它提供的操作API都有点类似。正确情况下，我们会在会根目录下创建一个自己项目的Znode。比如dubbo、kafka以便隔离数据。和我们创建文件夹的思路一样</p><h4 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h4><ul><li>在ZooKeeper中每一个节点都称之为znode，它本身可以有子节点，也可以有数据。</li><li>每一个节点分为临时节点和永久节点，临时节点在客户端断开后消失。也就是Session超时</li><li>每一个节点都有各自的版本号。可以通过命令行来显示节点信息</li><li>没当节点的数据发生改变，那么该节点的版本号都会累加（乐观锁）</li><li>删除、修改节点时，如果版本号不匹配会报错（乐观锁）</li><li>由于ZooKeeper的数据都存在内存中，每个节点的数据不建议存储过大的数据。几K即可</li><li>节点也可以设置acl权限。可以通过权限来限制用户的操作（unix的文件权限）</li></ul><p>这里需要注意znode分为临时节点和永久节点，临时节点在session关闭时会自动删除</p><h4 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h4><p>ZooKeeper在针对每个节点的操作，都会有监督者（watcher），当监控对象znode发生了变化，则触发watcher事件，可以理解为监听器。zk中的watcher是一次性的，触发后立即销毁</p><p>父节点、子节点 增删改都能够触发watcher事件。 具体的watcher事件</p><ol><li>创建节点触发， NodeCreated</li><li>修改节点触发，NodeDataChanged</li><li>删除节点触发，NodeDeleted</li><li>增加子节点触发，NodeChildrenChanged</li><li>删除子节点触发，NodeChildrenChanged</li><li>修改子节点不触发监听</li></ol><blockquote><p>这里我建议自己在命令行或者用代码api来自己体验下</p></blockquote><h2 id="ZooKeeper命令行"><a href="#ZooKeeper命令行" class="headerlink" title="ZooKeeper命令行"></a>ZooKeeper命令行</h2><p>了解基本的命令行，其实ZooKeeper的命令行并不多，这里只做简单介绍</p><p>执行<code>./zkCli.sh</code>即可打开命令行</p><h3 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h3><p>ls path [watch] 查询目录</p><p>watch 设置子节点的watch事件</p><p>stat path [watch] 查询详细信息</p><p>watch 设置当前节点的watch事件（下面的watch都是类似的机制不在说明）</p><p>节点信息如下：</p><ul><li>cZxid 创建的id</li><li>ctime 创建的时间</li><li>mZxid 修改的id</li><li>mtime 修改的时间</li><li>pZxid 父节点的id</li><li>cversion 子节点的version</li><li>dataVersion 数据的version</li><li>aclVersion  权限的version</li><li>ephemeraOwner 0x0为永久节点，其他为临时节点（待定）</li><li>datalength 数据长度</li><li>numChildren 子节点的大小</li></ul><blockquote><p>zxid:ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生<br>创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p></blockquote><p>ls2 path [watch] 查询目录,同时展示节点的信息</p><p>get path [watch] 可以将目录的数据取出来</p><h3 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h3><p>create [-s] [-e] path data acl</p><p>-e 临时节点<br>-s 顺序节点 在创建文件夹会在后面自动添加1开始的顺序</p><p>create /test/name hello-world</p><h3 id="修改命令"><a href="#修改命令" class="headerlink" title="修改命令"></a>修改命令</h3><p>set path data [version]</p><p>version 主要用于更新时的乐观锁</p><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><p>delete path [version]</p><p>version 主要用于删除时的乐观锁</p><h2 id="ZooKeeper的集群"><a href="#ZooKeeper的集群" class="headerlink" title="ZooKeeper的集群"></a>ZooKeeper的集群</h2><p>前面已经了解的ZooKeeper的概念，已经他能够为我们做什么。现在来了解一下ZooKeeper是怎么保证数据的统一性。以及自身集群的高可用。</p><h3 id="ZooKeeper-中的角色"><a href="#ZooKeeper-中的角色" class="headerlink" title="ZooKeeper 中的角色"></a>ZooKeeper 中的角色</h3><p>ZooKeeper在实际生产环境中是推荐使用集群方式。</p><p>在ZooKeeper的集群中引入了Leader、Follower、Observer三种角色。如下图所示</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-cluster-12y789gcuh982gq.png" alt="ZooKeeper集群"></p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-cluster-12y789gcuh982gq.png" alt="ZooKeeper集群角色表"></p><p>ZooKeeper集群中的所有机器会通过Leader选举过程来选定一台成为Leader的机器。<br>该Leader既可以为客户端提供读服务和写服务，但是Follower和Observer都只能提供读服务。Follower和Observer的唯一区别就是不参与Leader的选举过程，Observer仅仅是用提升服务的读取速度而存在的。因为Follower的无限增多也会影响选举的性能。</p><p>ZooKeeper的核心是原子广播，这个机制保证各个Server之间的同步。实现这个机制的协议叫Zab协议。Zab协议有两种模式：恢复模式（选主）和广播模式（同步）  </p><p>当Leader服务器出现崩溃，重启，网络中断等异常情况时，Zab协议会进入恢复模式并选举出新的Leader服务  </p><p>大致步骤如下：</p><ol><li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li><li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li><li>Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li><li>Broadcast（广播阶段） 到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><blockquote><p>这里通过第一条的规则，所以ZooKeeper部署推荐为单数服务，假如3台机器。最大允许宕机一台。而四台机器也是最大允许宕机一台。所以并不推荐部署双数机器部署  </p></blockquote><h3 id="ZooKeeper的读写机制"><a href="#ZooKeeper的读写机制" class="headerlink" title="ZooKeeper的读写机制"></a>ZooKeeper的读写机制</h3><ul><li>Zookeeper是一个由多个server组成的集群</li><li>一个leader，多个follower</li><li>每个server保存一份数据副本</li><li>全局数据一致</li><li>分布式读写</li><li>更新请求转发，由leader实施</li></ul><h3 id="Zookeeper的保证"><a href="#Zookeeper的保证" class="headerlink" title="Zookeeper的保证"></a>Zookeeper的保证</h3><ul><li>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</li><li>数据更新原子性，一次数据更新要么成功，要么失败</li><li>全局唯一数据视图，client无论连接到哪个server，数据视图都是一致的</li><li>实时性，在一定事件范围内，client能读到最新数据</li></ul><h3 id="Zookeeper的选举方式"><a href="#Zookeeper的选举方式" class="headerlink" title="Zookeeper的选举方式"></a>Zookeeper的选举方式</h3><p>首先选举必须要半数通过才行</p><p>简单模拟一下：</p><ul><li>A提案说，我要选自己，B你同意吗？C你同意吗？B说，我同意选A；C说，我同意选A。(注意，这里超过半数了，其实在现实世界选举已经成功了。但是计算机世界是很严格，另外要理解算法，要继续模拟下去。)</li><li>接着B提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；C说，A已经超半数同意当选，B提案无效。</li><li>接着C提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；B说，A已经超半数同意当选，C的提案无效。</li><li>选举已经产生了Leader，后面的都是follower，只能服从Leader的命令。而且这里还有个小细节，就是其实谁先启动谁当头。</li></ul><h3 id="Zab协议和Paxos算法"><a href="#Zab协议和Paxos算法" class="headerlink" title="Zab协议和Paxos算法"></a>Zab协议和Paxos算法</h3><p>Paxos算法应该可以说是ZooKeeper的灵魂了。但是ZooKeeper并没有完全采用Paxos算法 ，而是使用ZAB协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像Paxos算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p><p>这里Paxos算法暂时没什么了解，可以参考一些文章和一些书籍了解</p><ul><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">从Paxos到ZooKeeper</a></li><li><a href="http://codemacro.com/2014/10/15/explain-poxos/" target="_blank" rel="noopener">图解分布式一致性协议Paxos</a></li><li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">实例详解ZooKeeper ZAB协议、分布式锁与领导选举</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ZooKeeper本身就是一个分布式程序。超过半数以上存活，ZooKeeper就能正常服务</li><li>ZooKeeper的数据保存在内中，保证低延迟和高吞吐量，也不建议在znode中保存过大的数据</li><li>ZooKeeper推荐使用在读多写少的场景写，上面我们可以到了ZooKeeper只有leader才能执行写操作，这样做确实天然的保证的其顺序性，但是也影响了性能</li><li>znode有临时节点和永久节点的区分，临时节点在Session关闭时删除。（Session的关闭时通过Session超时来决定的，如果断开后再超时时间连上来Session是会继续维持）</li><li>ZooKeeper对于客户端主要提供两个操作：数据的增删改查和数据的监听服务</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/raphael5200/p/5285583.html" target="_blank" rel="noopener">https://www.cnblogs.com/raphael5200/p/5285583.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper&quot;&gt;&lt;a href=&quot;#zookeeper&quot; class=&quot;headerlink&quot; title=&quot;zookeeper&quot;&gt;&lt;/a&gt;zookeeper&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://yoursite.com/2019/12/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/12/30/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2019-12-30T15:12:12.000Z</published>
    <updated>2019-12-30T18:50:50.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式项目中必然而然的肯定会接触到分布式锁，相比诸如限流、熔断、分布式锁等其他技术。分布式锁在分布式项目是肯定会遇到的。因为其他技术可能在你的项目使用人数不多，业务简单而不需要。但是分布式锁在业务上基本是必须处理的。</p><p>目前分布式锁主流的实现方案有:redis分布式锁、ZooKeeper分布式锁两种。当然还有其他，比如基础关系型数据库来做分布式锁也有。这里只讲这两个。</p><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><h3 id="基本原理-RedLock"><a href="#基本原理-RedLock" class="headerlink" title="基本原理-RedLock"></a>基本原理-RedLock</h3><p>redis分布式锁，在redis官方叫RedLock。其实现也主要分为两个阶段。</p><h4 id="加锁-RedLock"><a href="#加锁-RedLock" class="headerlink" title="加锁-RedLock"></a>加锁-RedLock</h4><p>redis中加锁主要通过set命令来解决其中还用到了<code>nx</code>和<code>px</code>参数(在redis2.6.12版本后set命令增加了很多新的参数，所以理论上setnx、setex、psetex会被set命令取代，后续也不推荐使用以上命令，可能后续版本会被不推荐或者移除，具体可查看官网)来控制。</p><p><code>SET key my_random_value NX PX 30000</code></p><p>比如通过以上命令就可以获取锁，由于NX的特性只有在key不存在时才能设置成功保证了锁的独占性，而PX则保证了在锁的安全性，避免获取锁的客户端在崩溃后，锁能够自然释放掉。其中<code>my_random_value</code>可以设置为一个随机值，必须保证该值得全局唯一性</p><h4 id="解锁-RedLock"><a href="#解锁-RedLock" class="headerlink" title="解锁-RedLock"></a>解锁-RedLock</h4><p>解锁的过程就可以直接使用DEL命令来解决，但是为了保证加锁和解锁是同一个客户端，所以我们要校验一下<code>my_random_value</code>是否正确。这里可以为了保证其原子性可以使用Lua脚本来完成</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上就是最基本的redis锁的原理</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种锁肯定也有缺点。在redis主从哨兵的环境中。比如我们在主服务器获取了锁。此时主服务宕机。由于redis主从复制的异步特性，该key值没有同步到从服务器。并且完成了选举，此时第二个客户端就可能直接在新的主服务器获取到锁。所以就可能存在两个客户端同时获取到锁。</p><p>所以我们在核心业务的逻辑处理中要自己去保证被加锁的代码块的幂等性，不会因为分布式锁的问题而导致出现核心业务受损。</p><blockquote><p>不知道有什么完美的解决方案，对redis内部的架构不大了解。待定！</p></blockquote><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson是redis的一个java客户端。也是redis官网推荐的客户端（Spring-data-redis默认使用的Jedis），其中Redisson也对redis的分布式锁进行封装处理。比如对其支持可重复锁，公平锁等扩张，以便我们更好的使用Redis分布式锁。来简单看下Redisson的内部源码实现</p><p>这里首先要特别注意下<strong>由于Redisson的版本更迭比较快，我发现锁的内部实现代码。每个版本都有一些差异。基本原理都是一样的</strong>我用的SpringBoot所以版本也都一样。</p><p>Redisson Version : 3.11.3<br>Redisson SpringBoot start Version ：3.11.3</p><h4 id="Redisson分布式锁的基本使用"><a href="#Redisson分布式锁的基本使用" class="headerlink" title="Redisson分布式锁的基本使用"></a>Redisson分布式锁的基本使用</h4><p>Redisson的分布式锁使用和Java中的<code>ReentrantLock</code>的使用是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">"myKey"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 直接尝试获取锁</span></span><br><span class="line">        lock.tryLock(<span class="number">1</span>, TimeUnit.MINUTES); <span class="comment">// 也可以尝试获取锁 1分钟</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是简单的lock使用。接下来来看下其源码实现</p><h4 id="获取lock"><a href="#获取lock" class="headerlink" title="获取lock"></a>获取lock</h4><p>首先在了解过<code>ReentrantLock</code>的实现上，在看其实现就会简单很多。</p><p>先看下<code>RLock lock = redissonClient.getLock(&quot;myKey&quot;);</code>这句主要做了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(connectionManager.getCommandExecutor(), name); <span class="comment">// 构造函数在下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="comment">// 命令执行器</span></span><br><span class="line">    <span class="keyword">this</span>.commandExecutor = commandExecutor; </span><br><span class="line">    <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="comment">// 内部锁过期时间 30000毫秒</span></span><br><span class="line">    <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="keyword">this</span>.entryName = id + <span class="string">":"</span> + name;</span><br><span class="line">    <span class="comment">// redis的发布订阅</span></span><br><span class="line">    <span class="keyword">this</span>.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getLockPubSub();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redisson加锁的实现"><a href="#Redisson加锁的实现" class="headerlink" title="Redisson加锁的实现"></a>Redisson加锁的实现</h4><p>构造函数没有特别的，主要是获取Redis的连接的基本类。和一些默认的参数</p><p>lock获取完了，接下来看第二部加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId(); <span class="comment">// 获取当前线程id</span></span><br><span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId); <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="comment">// 获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果获取锁失败，则订阅到对应这个锁的channel  TODO 这一步还没有仔细看，待定</span></span><br><span class="line">    RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">    commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ttl = tryAcquire(leaseTime, unit, threadId); <span class="comment">// 再次尝试获取锁</span></span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 锁获取失败，等待ttl超时后再尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquireUninterruptibly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 取消订阅</span></span><br><span class="line">        unsubscribe(future, threadId);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下跟下去详细看到尝试获取锁的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123; <span class="comment">// 带有过期时间的获取锁</span></span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有带过期时间，则默认按30000毫秒来获取锁</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    <span class="comment">// 如果没有获取到锁，则开启一个定时任务不断的去刷新该锁的过期时间 这里是一个看门狗的角色</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着看tryLockInnerAsync方法</span></span><br><span class="line"><span class="comment">// 他使用了lua脚本来设置的，而且使用的Hash结构</span></span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                <span class="comment">// 锁不存在 hset获取锁，同时设置过期时间</span></span><br><span class="line">                <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 锁已经存在  </span></span><br><span class="line">                <span class="comment">// 判断锁是否为当前线程，如果是对其值+1,同时再次设置时间(主要解决可重入锁的问题)</span></span><br><span class="line">                <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 都不是则直接返回锁的ttl</span></span><br><span class="line">                <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                <span class="comment">// 下面是三个参数key[1] ARGV[1] ARGV[2] 分别是出传入key，时间，当前线程</span></span><br><span class="line">                <span class="comment">// 这里可以去简单了解下lua的调用语法即可</span></span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在了解<code>key[1] ARGV[1] ARGV[2]</code>是什么后很简单了。</p><p>实际上他为了一个map结构的数据。</p><p>key - 锁的名称<br>filed - 随机字符串+线程ID 值为1<br>value - 线程ID 会随着的递增来实现可重入锁</p><p>加锁基本就已经完成！ 接着来看下解锁</p><h4 id="Redisson解锁的实现"><a href="#Redisson解锁的实现" class="headerlink" title="Redisson解锁的实现"></a>Redisson解锁的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;Void&gt;();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId); <span class="comment">// 解锁的具体方法</span></span><br><span class="line"></span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 锁不存在异常 关闭前面开启的定时任务，抛出异常</span></span><br><span class="line">            cancelExpirationRenewal(threadId);</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁和持锁人不是同一个任务 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            IllegalMonitorStateException cause = <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"attempt to unlock lock, not locked by current thread by node id: "</span></span><br><span class="line">                    + id + <span class="string">" thread-id: "</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁成功 关闭前面开启的定时任务</span></span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line">        result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着直接看解锁的代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lua脚本</span></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 1. 判断锁是否等于当前线程，不等于则返回</span></span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">// 2. 对锁进行递减</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="comment">// &gt;0 则刷新一下过期时间</span></span><br><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="string">"return 0; "</span> +</span><br><span class="line">            <span class="string">"else "</span> +</span><br><span class="line">            <span class="comment">// 不是则删除key，并同时发布锁释放的消息</span></span><br><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span>+</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return nil;"</span>,</span><br><span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redisson的加锁和解锁基本完成。只需要简单的记住它所维护的map数据结构即可很好的记住它的原理</p><h4 id="Redisson中的看门狗"><a href="#Redisson中的看门狗" class="headerlink" title="Redisson中的看门狗"></a>Redisson中的看门狗</h4><p>Redisson有一个看门狗的角色特别说明下，就是前面说的那个定时任务</p><p>首先通过前面的原理已经知道Redis在加锁的时候是会设置一下key的时间的。假如在持有锁的客户端在设置的时间内依然正在执行中，那么就很有可能锁被其他客户端拿到造成两个客户端同时获取到锁。为了解决这个问题才引入了看门狗这个角色。它主要监控获取锁的线程如果该线程一直在运行中，它可以为这个锁的时间来续约。默认是每次续约30000毫秒。</p><p>这个角色具体有兴趣可以自己看下源码。</p><h2 id="ZooKeeper分布式锁"><a href="#ZooKeeper分布式锁" class="headerlink" title="ZooKeeper分布式锁"></a>ZooKeeper分布式锁</h2><p>ZooKeeper的分布式锁首先我们要知道ZooKeeper的基本原理和内存模型。具体可以看我的另外一篇文章，这里不多做介绍了！</p><h3 id="基本原理-Zookeeper"><a href="#基本原理-Zookeeper" class="headerlink" title="基本原理-Zookeeper"></a>基本原理-Zookeeper</h3><h4 id="加锁-ZooKeeper"><a href="#加锁-ZooKeeper" class="headerlink" title="加锁-ZooKeeper"></a>加锁-ZooKeeper</h4><p>加锁主要是通过zookeeper来创建一个临时顺序节点。然后检查自己的节点是否为顺序中最小的那一个，如果不是则监听自己上一个顺序的节点等待被唤醒</p><p>实际就是类似维护了一个FIFO的队列，然后依次监听自己的上一个节点。就像链式结构一样</p><p>这里的临时节点可以保证，自己掉线后，由zookeeper来删除节点，最后通知下一个节点。保证链式不断。</p><h4 id="解锁-ZooKeeper"><a href="#解锁-ZooKeeper" class="headerlink" title="解锁-ZooKeeper"></a>解锁-ZooKeeper</h4><p>解锁就比较简单了。删除自己的节点即可。通过zookeeper的监听机制来通知其他节点</p><h3 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h3><p>既然Redis推荐Redisson，那么ZooKeeper肯定推荐的实现代码！这里推荐curator客户端。同时是基于ZooKeeper做一些开发。可推荐使用该客户端。因为原生客户端不大好用，比如由于ZooKeeper的watch绑定机制每次触发一次就会失效需要重新绑定。这里该客户端已经帮我们实现了动态绑定。避免我们写代码时忘记。详细使用可以自己查看官网了！</p><h4 id="Curator的基本使用"><a href="#Curator的基本使用" class="headerlink" title="Curator的基本使用"></a>Curator的基本使用</h4><p>这里用的版本是2.8.0，其他版本的源码可能有些许出入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里简单看下使用的代码。非常简单。上面那部分代码可以集成在Spring中。统一使用<code>CuratorFramework</code>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExponentialBackoffRetry retry = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework framework = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">"192.168.72.253:2181,192.168.72.253:2182,192.168.72.253:2183"</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">50000</span>)</span><br><span class="line">        .connectionTimeoutMs(<span class="number">50000</span>)</span><br><span class="line">        .retryPolicy(retry)</span><br><span class="line">        .namespace(<span class="string">"duteliang"</span>)</span><br><span class="line">        .build();</span><br><span class="line">framework.start();</span><br><span class="line"></span><br><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(framework,<span class="string">"/zl/lock/name"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    interProcessMutex.acquire(); <span class="comment">// 加锁</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    interProcessMutex.release(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Curator加锁的实现"><a href="#Curator加锁的实现" class="headerlink" title="Curator加锁的实现"></a>Curator加锁的实现</h4><p>简单看下<code>internalLock</code>的内部实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 查询缓存是否已经获取到锁了</span></span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="keyword">null</span> ) &#123; <span class="comment">// 已经获取到锁，可重入锁</span></span><br><span class="line">        lockData.lockCount.incrementAndGet(); <span class="comment">// lockCount +1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="comment">// 获取锁成功，添加缓存</span></span><br><span class="line">        LockData newLockData = <span class="keyword">new</span> LockData(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败 返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中重点就是<code>internals.attemptLock</code>获取锁这个方法！继续看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>      startMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> Long      millisToWait = (unit != <span class="keyword">null</span>) ? unit.toMillis(time) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="keyword">null</span>) ? <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">    <span class="keyword">int</span>             retryCount = <span class="number">0</span>;</span><br><span class="line">    String          ourPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         hasTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         isDone = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> ( !isDone )&#123;</span><br><span class="line">        isDone = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建节点, 临时、顺序节点</span></span><br><span class="line">            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">            <span class="comment">// 判断是否获取锁，同时阻塞自己。关键部分</span></span><br><span class="line">            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">        &#125;<span class="keyword">catch</span> ( KeeperException.NoNodeException e )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )&#123;</span><br><span class="line">                isDone = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( hasTheLock )&#123;</span><br><span class="line">        <span class="keyword">return</span> ourPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建节点, 临时、顺序节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String ourPath;</span><br><span class="line">    <span class="keyword">if</span> (lockNodeBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ourPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要就是两步</p><ol><li>创建临时顺序节点</li><li>循环对顺序节点和自己进行检查，来判断自己是否可以获取锁</li></ol><p>接下来看第二部的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> doDelete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这一步是实现可撤销锁的动作，具体还没有研究</span></span><br><span class="line">        <span class="keyword">if</span> (revocable.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环获取锁</span></span><br><span class="line">        <span class="keyword">while</span> ((client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock) &#123;</span><br><span class="line">            List&lt;String&gt; children = getSortedChildren(); <span class="comment">// 获取所有顺序节点，注意已经排序好了。从小到大</span></span><br><span class="line">            String sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// 获取顺序节点的名称</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这一步就不贴源码了，可以自己看下比较简单</span></span><br><span class="line">            <span class="comment">// 主要判断当前节点是否为所有节点的第一个，如果是则获取到锁sTheLock=true, </span></span><br><span class="line">            <span class="comment">// 如果不是则获取到上一个顺序节点的名称</span></span><br><span class="line">            PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            <span class="keyword">if</span> (predicateResults.getsTheLock()) &#123; <span class="comment">// 获取到锁，返回</span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch(); <span class="comment">// 上一个顺序节点的完成名称</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 监听上一个节点、监听内代码在下面有贴。简单的notifyAll代码</span></span><br><span class="line">                        client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                        <span class="keyword">if</span> (millisToWait != <span class="keyword">null</span>) &#123; <span class="comment">// wait 开始阻塞线程等待</span></span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                            startMillis = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (millisToWait &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                doDelete = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            wait(millisToWait);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                        <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        doDelete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doDelete) &#123; <span class="comment">// 如果出现程序异常，则删除自己的节点。</span></span><br><span class="line">            deleteOurPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haveTheLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里补充一下监听的代码。主要做了什么。</span></span><br><span class="line"><span class="comment">// 主要通过 wait 和 notifyAll 的组合来处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyFromWatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，其主要逻辑</p><ol><li>获取所有顺序节点</li><li>判断自己是否为顺序中最小的那个节点，是就获取锁</li><li>不是则获取自己上一个节点，然后watch它。等待唤醒</li></ol><p>这里为了便于理解可以参考一下下面的逻辑图</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-lock-asp.jpg" alt="zookeeper加锁流程图"></p><h4 id="Curator解锁的实现"><a href="#Curator解锁的实现" class="headerlink" title="Curator解锁的实现"></a>Curator解锁的实现</h4><p>解锁就是比较简单了。就是删除节点。不多介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Thread currentThread = Thread.currentThread();</span><br><span class="line">    InterProcessMutex.LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> (lockData == <span class="keyword">null</span>) &#123; <span class="comment">// 当前没有获取到锁。解锁失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"You do not own the lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newLockCount = lockData.lockCount.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (newLockCount &gt; <span class="number">0</span>) &#123; <span class="comment">// 解锁成功</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newLockCount &lt; <span class="number">0</span>) &#123; <span class="comment">// 小于0，程序不正常。抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Lock count has gone negative for lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 删除节点，触发监听器</span></span><br><span class="line">        internals.releaseLock(lockData.lockPath);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除缓存</span></span><br><span class="line">        threadData.remove(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里基本讲完了Redis和ZooKeeper分布式锁的原理和实现。当然了解原理后可以自己去滚轮子，但是要注意很多细节部分。推荐还是直接使用上面的框架。</p><p>那么Redis和ZooKeeper分布式锁，哪个好一点了。</p><p>我认为首先两者在性能上面都是完全能够在生产环境使用的，两者之间的主要区别在于：</p><ol><li>Redis分布式锁上面已经讲过在主从集群环境中，有一个缺点。就是有可能两个客户端同时获取到锁，ZooKeeper就不存在这种。这主要是两者设计理念所造成的。就是我们常说的CAP原则，ZooKeeper保证的是CP（容错性和一致性），而redis保证的是AP（容错性和可用性）。具体可以去了解一下CAP的设计原则。</li><li>ZooKeeper在锁等待时会阻塞线程，不需要通过循环来解决。这也是由于ZooKeeper天然提供watch机制所带来的好处</li><li>ZooKeeper由于CP所带来的强一致性，性能没有redis好，同时由于ZooKeeper的实现中频繁的删除添加节点也有影响。但是ZooKeeper并不慢，只是与Redis比较而言</li></ol><p>所以如果能使用ZooKeeper我还是推荐使用ZooKeeper，但是ZooKeeper在项目中很多时候是作为注册中心来使用（比如dubbo），如果你的项目没有使用ZooKeeper，那么也可以使用Redis来做分布式锁，毕竟大部分项目都会使用Redis来做缓存。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://redis.io/commands/set" target="_blank" rel="noopener">redis官网set命令说明</a><br><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a><br><a href="https://www.jianshu.com/p/47fd7f86c848" target="_blank" rel="noopener">分布式锁之Redis实现</a><br><a href="http://curator.apache.org/curator-recipes/shared-reentrant-lock.html" target="_blank" rel="noopener">curator-lock-document</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
