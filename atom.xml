<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>duteliang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-17T18:16:59.293Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>duteliang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AOP详解</title>
    <link href="http://yoursite.com/2020/01/15/framework/aop%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/01/15/framework/aop%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-01-15T09:57:51.000Z</published>
    <updated>2020-01-17T18:16:59.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP详解"><a href="#AOP详解" class="headerlink" title="AOP详解"></a>AOP详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AOP面向切面编程，作为Spring中核心的功能之一，这里简单讲解了一下AOP的使用和原理。</p><p>讲解AOP之前需要提前掌握几个知识：IOC，Bean的生命周期，BeanPostProcessor，代理模式。尤其是后置处理器（BeanPostProcessor）是Spring在AOP的实现方式</p><h2 id="AOP的基本使用"><a href="#AOP的基本使用" class="headerlink" title="AOP的基本使用"></a>AOP的基本使用</h2><p>首先先复习一下AOP的基本概念和基本使用，这里只贴出注解方式（基于SpringBoot）。</p><h3 id="AOP的增强类型"><a href="#AOP的增强类型" class="headerlink" title="AOP的增强类型"></a>AOP的增强类型</h3><ol><li><code>@Before</code>: 前置增强</li><li><code>@After</code>: 后置增强</li><li><code>@AfterReturning</code>: 返回增强</li><li><code>@AfterThrowing</code>: 异常增强</li><li><code>@Around</code>: 环绕增强</li></ol><h3 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h3><ul><li><strong>JoinPoint</strong>（连接点）：被拦截的点，在Spring指类的任意方法。</li><li><strong>Pointcut</strong>（切入点）：需要切入的点。可以理解为是一个匹配条件，用它来找到和判断某个方法是不是连接点。</li><li><strong>Advice</strong>（通知 / 增强）：Advice是织入到目标类连接点上的一段代码，上面的5大类型就是指的是Advice。</li><li><strong>Weaving</strong>（织入）： 织入就是增强的代码何时添加到连接点。目前AOP只要有三种：编译期织入、装载期织入、运行时织入。Spring选择运行时织入，主要通过动态代理来实现。</li></ul><h3 id="AOP的基本使用-1"><a href="#AOP的基本使用-1" class="headerlink" title="AOP的基本使用"></a>AOP的基本使用</h3><p>在SpringBoot只需要加入AOP的POM资源即可使用Spring Aop。<br>我这里使用的SpringBoot的<code>2.1.9.RELEASE</code>版本。AOP作为Spring Framework的核心功能，版本差异不大。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面列出简单的AOP配置和使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopService</span> <span class="keyword">implements</span> <span class="title">AopServiceI</span></span>&#123;</span><br><span class="line">    <span class="comment">// 被代理方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">aopTest</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是AOP 实际方法：&#123;&#125;"</span>+name);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Aop配置</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopTestAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(public * com.duteliang.webbase.aop.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是AOP 前置增强！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是AOP 后置增强！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"pointCut()"</span>,returning = <span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint,String result)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是AOP 返回增强！返回值："</span>+result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"pointCut()"</span>,throwing = <span class="string">"e"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint,Exception e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是AOP 异常增强！异常:"</span>+e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"pointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">Around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是环绕AOP 前置通知！"</span>);</span><br><span class="line">        Object proceed;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = pjp.proceed();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable t)&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是环绕AOP 异常通知！异常:"</span>+t.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> t;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"我是环绕AOP 后置通知！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"我是环绕AOP 返回通知！返回值："</span>+proceed);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不帖执行代码流程了。毕竟估计都很熟练了。 顶多有些对<code>PointCut</code>的配置写法不怎么熟悉，我在后面章节主要说明一下其语法即可。</p><h2 id="AOP的原理"><a href="#AOP的原理" class="headerlink" title="AOP的原理"></a>AOP的原理</h2><p>前面已经讲过在Spring中的AOP主要是通过动态代理来实现。什么是动态代理？可以看下我的其他文章有动态代理这一部分。简单讲解了动态代理的问题。</p><p>这里主要以SpringBoot为基础来简单说明（PS：源码很复杂，我不大想把复杂的源码讲解的很清楚，主要写了一下我比较关注的点）</p><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>Spring要引入AOP其实还需要添加该注解<code>@EnableAspectJAutoProxy</code>。SpringBoot已经默认帮我们加了（在<code>AopAutoConfiguration</code>中可找到相关代码）,所以导致我们无感知。</p><p>看下该注解的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(AspectJAutoProxyRegistrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAspectJAutoProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种注解很明显，重点在@Import中。继续跟上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重点进入代码。下面</span></span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 非重点</span></span><br><span class="line">        AnnotationAttributes enableAspectJAutoProxy =</span><br><span class="line">                AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (enableAspectJAutoProxy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"proxyTargetClass"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="string">"exposeProxy"</span>)) &#123;</span><br><span class="line">                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfigUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注意在这个方法中已经把AnnotationAwareAspectJAutoProxyCreator的字节码传入方法了</span></span><br><span class="line">        <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator<span class="class">.<span class="keyword">class</span>, <span class="title">registry</span>, <span class="title">source</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerOrEscalateApcAsRequired</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Class&lt;?&gt; cls, BeanDefinitionRegistry registry, @Nullable Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(registry, <span class="string">"BeanDefinitionRegistry must not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逻辑判断检查是否已经注册过</span></span><br><span class="line">        <span class="keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;</span><br><span class="line">            BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);</span><br><span class="line">            <span class="keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());</span><br><span class="line">                <span class="keyword">int</span> requiredPriority = findPriorityForClass(cls);</span><br><span class="line">                <span class="keyword">if</span> (currentPriority &lt; requiredPriority) &#123;</span><br><span class="line">                    apcDefinition.setBeanClassName(cls.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个cls 是 AnnotationAwareAspectJAutoProxyCreator.class 注册的是它</span></span><br><span class="line">        RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(cls);</span><br><span class="line">        beanDefinition.setSource(source);</span><br><span class="line">        beanDefinition.getPropertyValues().add(<span class="string">"order"</span>, Ordered.HIGHEST_PRECEDENCE);</span><br><span class="line">        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        <span class="comment">// 重点：注册了一个Bean</span></span><br><span class="line">        registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);</span><br><span class="line">        <span class="keyword">return</span> beanDefinition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出<code>@EnableAspectJAutoProxy</code>实际就是注册了<code>AnnotationAwareAspectJAutoProxyCreator</code>这个bean而已。<br>而这个类其实就是用来为bean创建动态代理的，同时它实现了<code>BeanPostProcessor</code>,可以很好的在Bean的初始化前后修改Bean</p><h3 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h3><p>注意这里的<code>postProcessBeforeInstantiation</code>并不是<code>BeanPostProcessor</code>的初始化步骤。而是<code>InstantiationAwareBeanPostProcessor</code>对<code>BeanPostProcessor</code>接口的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*它是有IOC启动时。Spring特别处理调用的*/</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bean的生命周期 也就是bean创建后调用, 它是继承BeanPostProcessor而来的*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要找到具体源码。这还要进入IOC启动的经典方法<code>refresh</code>中</p><p>大致类图：refresh –&gt; finishBeanFactoryInitialization –&gt; preInstantiateSingletons –&gt; getBean –&gt; doGetBean –&gt; createBean</p><p>具体类在：<code>AbstractAutowireCapableBeanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    ... 忽略无关代码</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        <span class="comment">// 给后置处理器一个机会 用代理类替换目标类。（我个人觉得这里有点迷惑性） 实际这里永远返回null</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建bean</span></span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">        <span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">        <span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    ... 忽略无关代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部使用的后置处理器初始化（postProcessBeforeInstantiation）"><a href="#内部使用的后置处理器初始化（postProcessBeforeInstantiation）" class="headerlink" title="内部使用的后置处理器初始化（postProcessBeforeInstantiation）"></a>内部使用的后置处理器初始化（postProcessBeforeInstantiation）</h4><p>接着进入看下它为什么要给后置处理器一个机会?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">        <span class="comment">// 基本的检查</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在AnnotationAwareAspectJAutoProxyCreator中这里永远返回null，所以只看这个初始化</span></span><br><span class="line">                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="comment">// 这里实际就是手工调用了所有的 InstantiationAwareBeanPostProcessor 的初始化方法</span></span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看下<code>AnnotationAwareAspectJAutoProxyCreator</code>的初始化方法</p><p>这里不展开了，展开就太大了。我写下具体做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    Object cacheKey = getCacheKey(beanClass, beanName); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 判断该Bean是否已经被增强处理过</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否为基础类 比如：Advice.class,Pointcut.class等AOP基础类就不需要增强了</span></span><br><span class="line">        <span class="comment">// 判断是否可以忽略，这里比较重点</span></span><br><span class="line">        <span class="comment">// 感兴趣的可以去深入理解，主要是对bean进行匹配同时对该Bean的增强代码进行缓存</span></span><br><span class="line">        <span class="keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断自定义的 目标资源？ 实际这里正常都是null，不会进入</span></span><br><span class="line">    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (targetSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.targetSourcedBeans.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);</span><br><span class="line">        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以后置处理器的初始化方法，主要就是为后面的after方法做缓存准备，比如准备增强代码，缓存需要被代理的bean的Advice</p><h4 id="标准的后置处理器的After方法"><a href="#标准的后置处理器的After方法" class="headerlink" title="标准的后置处理器的After方法"></a>标准的后置处理器的After方法</h4><p>接下来就是正常的后置处理器的使用了。 会在Bean的生命周期的过程中调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line">            <span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 都是一些基本的判断</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前bean的 增强。 前面的初始化已经处理好了。如果获取到了则表示该bean有增强处理，需要创建代理类</span></span><br><span class="line">     Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line">        <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        Object proxy = createProxy(</span><br><span class="line">                bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line">        <span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分相对好理解多了。创建代理类的核心部分，我贴下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">        Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">        <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                    <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出通过其方法的接口的情况来选择走什么代理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整体下来AOP的核心在于<code>AnnotationAwareAspectJAutoProxyCreator</code>其实它是一个特殊的<code>BeanPostProcessor</code>后置处理器。</p><p>通过<code>InstantiationAwareBeanPostProcessor</code>来初始化bean的增强代码。同时保存缓存</p><p>通过<code>BeanPostProcessor</code>的后置处理器，根据该bean是否有增强代码。来选择是否包装成代理类</p><p>这里没有讲解他的增强（Advice）是怎么缓存和实现的。有兴趣可以自己阅读源码！</p><h2 id="扩充：PointCut的写法"><a href="#扩充：PointCut的写法" class="headerlink" title="扩充：PointCut的写法"></a>扩充：PointCut的写法</h2><p>在实际使用中有时候AOP可能用的比较少，对于切点表达式可能很生疏。这里简单讲解一下其语法。</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/spring/aop-pointCut-name.jpg" alt="切入点基础信息"></p><blockquote><p>由于没有找到画这个比较好的工具，凑合着看吧</p></blockquote><p>首先看下指示器的部分，也就是<code>execution</code>大致可分为以下的表格</p><table><thead><tr><th>AspectJ指示器</th><th>描述</th></tr></thead><tbody><tr><td>execution()</td><td>用于匹配连接点的执行方法(常用)</td></tr><tr><td>@annotation()</td><td>限定匹配带有注解的连接点(常用)</td></tr><tr><td>args()</td><td>限制连接点匹配参数为指定类型的执行方法</td></tr><tr><td>@args()</td><td>限制连接点匹配参数由指定注解标注的执行方法</td></tr><tr><td>this()</td><td>限制连接点匹配AOP代理的bean引用为指定类型的类</td></tr><tr><td>target</td><td>限制连接点匹配目标对象为指定类型的类</td></tr><tr><td>within()</td><td>限制连接点匹配指定的包类型</td></tr><tr><td>@target()</td><td>限制连接点匹配特定的执行对象，这些对象对于的类要具有指定类型的注解</td></tr><tr><td>@within()</td><td>限制连接点匹配指定注解所标记的类型</td></tr><tr><td>bean()</td><td>匹配bean的名称，支持*,这是Spring扩展独有的</td></tr></tbody></table><p>每个指示器几句话概况说明一哈</p><ul><li>execution()  这个就不说明了，常用的，注意public也可以不写。AOP本身就只能代理Public类型</li><li>@annotation(注解A)  匹配方法上有注解A上的情况（<strong>注意是方法，类上不行</strong>）</li><li>args(String) 匹配方法上参数为String的且只有一个。多个可以这么写：@Pointcut(“args(String,..)”) 但是第一个必须是String</li><li>@args(注解A) 匹配方法上面第一个参数有注解A,多个和args一样(<strong>注意是第一个参数上面有注解A，而不是第一个参数为注解A</strong>)</li><li>this(类A) 匹配类A下的所有方法</li><li>target(类A) 匹配类A下的所有方法</li><li>within() 主要是对包的扫描，比如within(包名.*) 可以对该包下所有的类进行拦截</li></ul><blockquote><p>注意 within 可以写*，但是target不行，target必须写一个完整的类名</p></blockquote><ul><li>@target(注解A) 匹配类上面有注解A的所有方法，注意和@annotation做比较</li><li>@within(注解A) 匹配被调用方法上是否有注解A</li><li>bean() 匹配bean的名称 支持*符号</li></ul><h3 id="target和-within的区别"><a href="#target和-within的区别" class="headerlink" title="@target和@within的区别"></a>@target和@within的区别</h3><p>这里对于@target和@within特别说明一下，两者看起来好像一样都是作用于类上的注解。实际上关注的点不一样。<br>@target关注的是类上是否有注解，@within关注的是调用方法上是否有注解</p><p>下面写个简单的例子说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@注解</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aop</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C的是测试，重点在A和B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; a.aop() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子如果使用<code>@within</code>就不会被拦截。为什么？ 因为<code>@within</code>关注的是调用方法上的类上是否有注解，上面A在调用<code>aop</code>方法时，实际是调用的父类的<code>aop</code>方法，而B类没有注解，所以拦截不到。如果A重写了<code>aop</code>方法就可以拦截到了。因为那时候实际调用的就是A上的方法。所以<code>@within</code>关注的是方法本身上面类的注解</p><p>上面换成<code>@target</code>就可以拦截到。<code>@target</code>只关注调用者本身是不是有注解，A上面有注解。我是用A来调用<code>aop</code>方法的，我不管这个<code>aop</code>是谁的，只要A上面有注解就行。</p><p>大概思路就是如此，大家可以自己测试一下！</p><h3 id="this的特别之处"><a href="#this的特别之处" class="headerlink" title="this的特别之处"></a>this的特别之处</h3><p>这里也把<code>this</code>说明一下，因为这个也有点不好理解。看起来好像和<code>target</code>一样</p><p><code>this</code>的要求比较严格，它实际匹配的是代理类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aop</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">aop</span><span class="params">()</span> &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 配置写法</span></span></span><br><span class="line"><span class="function"><span class="title">this</span><span class="params">(A)</span></span></span><br></pre></td></tr></table></figure><p>上面的代码。正常情况走的JDK动态代理。我们知道JDK动态代理只能代理接口。所有实际的代理类是B，而我们现在扫描的A所有匹配不到</p><p>如果我们强制走cglib代理，那么代理类就是A本身。这样就能匹配到了。</p><p>同样大家可以自己测试！</p><h3 id="其他参数写法"><a href="#其他参数写法" class="headerlink" title="其他参数写法"></a>其他参数写法</h3><p>把指示器理解完，后面的一些写法其实都可以猜到了！</p><p>返回值：可以使用<em>，也可以指定类型<br>包名：可以使用 .. 来扫描所有子包，比如：`com.duteliang.webbase.aop..</em><code>就可以扫描</code>com.duteliang.webbase.aop`下的所有子孙类<br>类目：可以使用*匹配<br>参数：使用(..)，两点表示匹配所有</p><p>同样我们使用 且（&amp;&amp;）、或（||）、非（！）来组合切入点表达式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AOP详解&quot;&gt;&lt;a href=&quot;#AOP详解&quot; class=&quot;headerlink&quot; title=&quot;AOP详解&quot;&gt;&lt;/a&gt;AOP详解&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring,AOP,代理模式" scheme="http://yoursite.com/tags/Spring-AOP-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="http://yoursite.com/2019/12/30/microservices/zookeeper/"/>
    <id>http://yoursite.com/2019/12/30/microservices/zookeeper/</id>
    <published>2019-12-30T15:12:12.000Z</published>
    <updated>2019-12-31T11:50:30.631Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在现在分布式、微服务大行其道的今天，肯定都会接触ZooKeeper这个框架。本人也只是在Dubbo的项目中有使用过(当然Kafka的集群部署也是基于ZooKeeper,这个就不算使用了)。但是它可以做的事远不止在Dubbo中的使用。所以先了解了ZooKeeper的基本模型、概念以及使用，以便加深学习</p><h2 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h2><p>ZooKeeper 是一个开源的分布式协调服务,设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>ZooKeeper 是一个典型的分布式数据一致性解决方案。其主要应用场景：</p><ol><li>master节点选举，主节点挂了以后，从节点就会接收工作，并且节点是唯一的。保证高可用（比如Kafka集群）</li><li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他服务器。</li><li>发布与订阅。类似于消息队列MQ，dubbo发布者把数据发布到znode上，订阅者会拉出数据</li><li>分布式锁</li><li>集群管理，集群中保证数据的强一致性（Dubbo的注册中心）</li></ol><p>本人主要接触ZooKeeper还是在公司使用Dubbo的时候接触的，所以ZooKeeper主要是用于：服务的容错、负载均衡、查找服务和管理服务，还可以选择其作为配置中心的集中式管理。</p><h2 id="ZooKeeper的数据模型"><a href="#ZooKeeper的数据模型" class="headerlink" title="ZooKeeper的数据模型"></a>ZooKeeper的数据模型</h2><h3 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h3><p>在了解ZooKeeper的数据模型之前，有必要了解ZooKeeper的Session机制</p><p>Session是指客户端和服务端之间会话。在ZooKeeper中是指一个客户端与ZooKeeper之间的一次长连接。客户端在启动时会与服务端建立一个Tcp连接。后续客户端可已通过这个连接发送消息给服务端，也可以监听服务端发送来的消息。客户端和服务端有一个心跳机制来维持和判断这个连接的有效性，可以通过Session中的<code>sessionTimeout</code>值来设置一个客户端的超时时间。同时当由于服务器原因或者客户端主动要求端口连接的时候，只要在超时时间内重新连接任一一台ZooKeeper机器，那么之前创建的 Session仍然有效。</p><p>和我们平常接触到HttpSession一样，每次创建一次会话，服务端都会为该客户端分配一个SessionId，该SessionId也是全局唯一的。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>ZooKeeper的数据模型和我们经常使用的Unix/Linux的文件系统是类似的。</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/ZooKeeper-model-cbdsiaaaa2312y7r671f7f376ghucdvq793f271.jpg" alt="ZooKeepr的内存模型"></p><p>上图中我们可以比较明显看到和文件系统很像，实际它提供的操作API都有点类似。正确情况下，我们会在会根目录下创建一个自己项目的Znode。比如dubbo、kafka以便隔离数据。和我们创建文件夹的思路一样</p><h4 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h4><ul><li>在ZooKeeper中每一个节点都称之为znode，它本身可以有子节点，也可以有数据。</li><li>每一个节点分为临时节点和永久节点，临时节点在客户端断开后消失。也就是Session超时</li><li>每一个节点都有各自的版本号。可以通过命令行来显示节点信息</li><li>没当节点的数据发生改变，那么该节点的版本号都会累加（乐观锁）</li><li>删除、修改节点时，如果版本号不匹配会报错（乐观锁）</li><li>由于ZooKeeper的数据都存在内存中，每个节点的数据不建议存储过大的数据。几K即可</li><li>节点也可以设置acl权限。可以通过权限来限制用户的操作（unix的文件权限）</li></ul><p>这里需要注意znode分为临时节点和永久节点，临时节点在session关闭时会自动删除</p><h4 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h4><p>ZooKeeper在针对每个节点的操作，都会有监督者（watcher），当监控对象znode发生了变化，则触发watcher事件，可以理解为监听器。zk中的watcher是一次性的，触发后立即销毁</p><p>父节点、子节点 增删改都能够触发watcher事件。 具体的watcher事件</p><ol><li>创建节点触发， NodeCreated</li><li>修改节点触发，NodeDataChanged</li><li>删除节点触发，NodeDeleted</li><li>增加子节点触发，NodeChildrenChanged</li><li>删除子节点触发，NodeChildrenChanged</li><li>修改子节点不触发监听</li></ol><blockquote><p>这里我建议自己在命令行或者用代码api来自己体验下</p></blockquote><h2 id="ZooKeeper命令行"><a href="#ZooKeeper命令行" class="headerlink" title="ZooKeeper命令行"></a>ZooKeeper命令行</h2><p>了解基本的命令行，其实ZooKeeper的命令行并不多，这里只做简单介绍</p><p>执行<code>./zkCli.sh</code>即可打开命令行</p><h3 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h3><p>ls path [watch] 查询目录</p><p>watch 设置子节点的watch事件</p><p>stat path [watch] 查询详细信息</p><p>watch 设置当前节点的watch事件（下面的watch都是类似的机制不在说明）</p><p>节点信息如下：</p><ul><li>cZxid 创建的id</li><li>ctime 创建的时间</li><li>mZxid 修改的id</li><li>mtime 修改的时间</li><li>pZxid 父节点的id</li><li>cversion 子节点的version</li><li>dataVersion 数据的version</li><li>aclVersion  权限的version</li><li>ephemeraOwner 0x0为永久节点，其他为临时节点（待定）</li><li>datalength 数据长度</li><li>numChildren 子节点的大小</li></ul><blockquote><p>zxid:ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生<br>创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p></blockquote><p>ls2 path [watch] 查询目录,同时展示节点的信息</p><p>get path [watch] 可以将目录的数据取出来</p><h3 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h3><p>create [-s] [-e] path data acl</p><p>-e 临时节点<br>-s 顺序节点 在创建文件夹会在后面自动添加1开始的顺序</p><p>create /test/name hello-world</p><h3 id="修改命令"><a href="#修改命令" class="headerlink" title="修改命令"></a>修改命令</h3><p>set path data [version]</p><p>version 主要用于更新时的乐观锁</p><h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><p>delete path [version]</p><p>version 主要用于删除时的乐观锁</p><h2 id="ZooKeeper的集群"><a href="#ZooKeeper的集群" class="headerlink" title="ZooKeeper的集群"></a>ZooKeeper的集群</h2><p>前面已经了解的ZooKeeper的概念，已经他能够为我们做什么。现在来了解一下ZooKeeper是怎么保证数据的统一性。以及自身集群的高可用。</p><h3 id="ZooKeeper-中的角色"><a href="#ZooKeeper-中的角色" class="headerlink" title="ZooKeeper 中的角色"></a>ZooKeeper 中的角色</h3><p>ZooKeeper在实际生产环境中是推荐使用集群方式。</p><p>在ZooKeeper的集群中引入了Leader、Follower、Observer三种角色。如下图所示</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-cluster-12y789gcuh982gq.png" alt="ZooKeeper集群"></p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-cluster-12y789gcuh982gq.png" alt="ZooKeeper集群角色表"></p><p>ZooKeeper集群中的所有机器会通过Leader选举过程来选定一台成为Leader的机器。<br>该Leader既可以为客户端提供读服务和写服务，但是Follower和Observer都只能提供读服务。Follower和Observer的唯一区别就是不参与Leader的选举过程，Observer仅仅是用提升服务的读取速度而存在的。因为Follower的无限增多也会影响选举的性能。</p><p>ZooKeeper的核心是原子广播，这个机制保证各个Server之间的同步。实现这个机制的协议叫Zab协议。Zab协议有两种模式：恢复模式（选主）和广播模式（同步）  </p><p>当Leader服务器出现崩溃，重启，网络中断等异常情况时，Zab协议会进入恢复模式并选举出新的Leader服务  </p><p>大致步骤如下：</p><ol><li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li><li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li><li>Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li><li>Broadcast（广播阶段） 到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li></ol><blockquote><p>这里通过第一条的规则，所以ZooKeeper部署推荐为单数服务，假如3台机器。最大允许宕机一台。而四台机器也是最大允许宕机一台。所以并不推荐部署双数机器部署  </p></blockquote><h3 id="ZooKeeper的读写机制"><a href="#ZooKeeper的读写机制" class="headerlink" title="ZooKeeper的读写机制"></a>ZooKeeper的读写机制</h3><ul><li>Zookeeper是一个由多个server组成的集群</li><li>一个leader，多个follower</li><li>每个server保存一份数据副本</li><li>全局数据一致</li><li>分布式读写</li><li>更新请求转发，由leader实施</li></ul><h3 id="Zookeeper的保证"><a href="#Zookeeper的保证" class="headerlink" title="Zookeeper的保证"></a>Zookeeper的保证</h3><ul><li>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</li><li>数据更新原子性，一次数据更新要么成功，要么失败</li><li>全局唯一数据视图，client无论连接到哪个server，数据视图都是一致的</li><li>实时性，在一定事件范围内，client能读到最新数据</li></ul><h3 id="Zookeeper的选举方式"><a href="#Zookeeper的选举方式" class="headerlink" title="Zookeeper的选举方式"></a>Zookeeper的选举方式</h3><p>首先选举必须要半数通过才行</p><p>简单模拟一下：</p><ul><li>A提案说，我要选自己，B你同意吗？C你同意吗？B说，我同意选A；C说，我同意选A。(注意，这里超过半数了，其实在现实世界选举已经成功了。但是计算机世界是很严格，另外要理解算法，要继续模拟下去。)</li><li>接着B提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；C说，A已经超半数同意当选，B提案无效。</li><li>接着C提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；B说，A已经超半数同意当选，C的提案无效。</li><li>选举已经产生了Leader，后面的都是follower，只能服从Leader的命令。而且这里还有个小细节，就是其实谁先启动谁当头。</li></ul><h3 id="Zab协议和Paxos算法"><a href="#Zab协议和Paxos算法" class="headerlink" title="Zab协议和Paxos算法"></a>Zab协议和Paxos算法</h3><p>Paxos算法应该可以说是ZooKeeper的灵魂了。但是ZooKeeper并没有完全采用Paxos算法 ，而是使用ZAB协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像Paxos算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p><p>这里Paxos算法暂时没什么了解，可以参考一些文章和一些书籍了解</p><ul><li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">从Paxos到ZooKeeper</a></li><li><a href="http://codemacro.com/2014/10/15/explain-poxos/" target="_blank" rel="noopener">图解分布式一致性协议Paxos</a></li><li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">实例详解ZooKeeper ZAB协议、分布式锁与领导选举</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ZooKeeper本身就是一个分布式程序。超过半数以上存活，ZooKeeper就能正常服务</li><li>ZooKeeper的数据保存在内中，保证低延迟和高吞吐量，也不建议在znode中保存过大的数据</li><li>ZooKeeper推荐使用在读多写少的场景写，上面我们可以到了ZooKeeper只有leader才能执行写操作，这样做确实天然的保证的其顺序性，但是也影响了性能</li><li>znode有临时节点和永久节点的区分，临时节点在Session关闭时删除。（Session的关闭时通过Session超时来决定的，如果断开后再超时时间连上来Session是会继续维持）</li><li>ZooKeeper对于客户端主要提供两个操作：数据的增删改查和数据的监听服务</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/raphael5200/p/5285583.html" target="_blank" rel="noopener">https://www.cnblogs.com/raphael5200/p/5285583.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;zookeeper&quot;&gt;&lt;a href=&quot;#zookeeper&quot; class=&quot;headerlink&quot; title=&quot;zookeeper&quot;&gt;&lt;/a&gt;zookeeper&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://yoursite.com/2019/12/30/microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/12/30/microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2019-12-30T15:12:12.000Z</published>
    <updated>2019-12-31T11:50:25.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式项目中必然而然的肯定会接触到分布式锁，相比诸如限流、熔断、分布式锁等其他技术。分布式锁在分布式项目是肯定会遇到的。因为其他技术可能在你的项目使用人数不多，业务简单而不需要。但是分布式锁在业务上基本是必须处理的。</p><p>目前分布式锁主流的实现方案有:redis分布式锁、ZooKeeper分布式锁两种。当然还有其他，比如基础关系型数据库来做分布式锁也有。这里只讲这两个。</p><h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><h3 id="基本原理-RedLock"><a href="#基本原理-RedLock" class="headerlink" title="基本原理-RedLock"></a>基本原理-RedLock</h3><p>redis分布式锁，在redis官方叫RedLock。其实现也主要分为两个阶段。</p><h4 id="加锁-RedLock"><a href="#加锁-RedLock" class="headerlink" title="加锁-RedLock"></a>加锁-RedLock</h4><p>redis中加锁主要通过set命令来解决其中还用到了<code>nx</code>和<code>px</code>参数(在redis2.6.12版本后set命令增加了很多新的参数，所以理论上setnx、setex、psetex会被set命令取代，后续也不推荐使用以上命令，可能后续版本会被不推荐或者移除，具体可查看官网)来控制。</p><p><code>SET key my_random_value NX PX 30000</code></p><p>比如通过以上命令就可以获取锁，由于NX的特性只有在key不存在时才能设置成功保证了锁的独占性，而PX则保证了在锁的安全性，避免获取锁的客户端在崩溃后，锁能够自然释放掉。其中<code>my_random_value</code>可以设置为一个随机值，必须保证该值得全局唯一性</p><h4 id="解锁-RedLock"><a href="#解锁-RedLock" class="headerlink" title="解锁-RedLock"></a>解锁-RedLock</h4><p>解锁的过程就可以直接使用DEL命令来解决，但是为了保证加锁和解锁是同一个客户端，所以我们要校验一下<code>my_random_value</code>是否正确。这里可以为了保证其原子性可以使用Lua脚本来完成</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上就是最基本的redis锁的原理</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种锁肯定也有缺点。在redis主从哨兵的环境中。比如我们在主服务器获取了锁。此时主服务宕机。由于redis主从复制的异步特性，该key值没有同步到从服务器。并且完成了选举，此时第二个客户端就可能直接在新的主服务器获取到锁。所以就可能存在两个客户端同时获取到锁。</p><p>所以我们在核心业务的逻辑处理中要自己去保证被加锁的代码块的幂等性，不会因为分布式锁的问题而导致出现核心业务受损。</p><blockquote><p>不知道有什么完美的解决方案，对redis内部的架构不大了解。待定！</p></blockquote><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson是redis的一个java客户端。也是redis官网推荐的客户端（Spring-data-redis默认使用的Jedis），其中Redisson也对redis的分布式锁进行封装处理。比如对其支持可重复锁，公平锁等扩张，以便我们更好的使用Redis分布式锁。来简单看下Redisson的内部源码实现</p><p>这里首先要特别注意下<strong>由于Redisson的版本更迭比较快，我发现锁的内部实现代码。每个版本都有一些差异。基本原理都是一样的</strong>我用的SpringBoot所以版本也都一样。</p><p>Redisson Version : 3.11.3<br>Redisson SpringBoot start Version ：3.11.3</p><h4 id="Redisson分布式锁的基本使用"><a href="#Redisson分布式锁的基本使用" class="headerlink" title="Redisson分布式锁的基本使用"></a>Redisson分布式锁的基本使用</h4><p>Redisson的分布式锁使用和Java中的<code>ReentrantLock</code>的使用是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">"myKey"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 直接尝试获取锁</span></span><br><span class="line">        lock.tryLock(<span class="number">1</span>, TimeUnit.MINUTES); <span class="comment">// 也可以尝试获取锁 1分钟</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是简单的lock使用。接下来来看下其源码实现</p><h4 id="获取lock"><a href="#获取lock" class="headerlink" title="获取lock"></a>获取lock</h4><p>首先在了解过<code>ReentrantLock</code>的实现上，在看其实现就会简单很多。</p><p>先看下<code>RLock lock = redissonClient.getLock(&quot;myKey&quot;);</code>这句主要做了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(connectionManager.getCommandExecutor(), name); <span class="comment">// 构造函数在下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="comment">// 命令执行器</span></span><br><span class="line">    <span class="keyword">this</span>.commandExecutor = commandExecutor; </span><br><span class="line">    <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="comment">// 内部锁过期时间 30000毫秒</span></span><br><span class="line">    <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="keyword">this</span>.entryName = id + <span class="string">":"</span> + name;</span><br><span class="line">    <span class="comment">// redis的发布订阅</span></span><br><span class="line">    <span class="keyword">this</span>.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getLockPubSub();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redisson加锁的实现"><a href="#Redisson加锁的实现" class="headerlink" title="Redisson加锁的实现"></a>Redisson加锁的实现</h4><p>构造函数没有特别的，主要是获取Redis的连接的基本类。和一些默认的参数</p><p>lock获取完了，接下来看第二部加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId(); <span class="comment">// 获取当前线程id</span></span><br><span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId); <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="comment">// 获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果获取锁失败，则订阅到对应这个锁的channel  TODO 这一步还没有仔细看，待定</span></span><br><span class="line">    RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">    commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ttl = tryAcquire(leaseTime, unit, threadId); <span class="comment">// 再次尝试获取锁</span></span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 锁获取失败，等待ttl超时后再尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquireUninterruptibly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 取消订阅</span></span><br><span class="line">        unsubscribe(future, threadId);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下跟下去详细看到尝试获取锁的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123; <span class="comment">// 带有过期时间的获取锁</span></span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有带过期时间，则默认按30000毫秒来获取锁</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    <span class="comment">// 如果没有获取到锁，则开启一个定时任务不断的去刷新该锁的过期时间 这里是一个看门狗的角色</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着看tryLockInnerAsync方法</span></span><br><span class="line"><span class="comment">// 他使用了lua脚本来设置的，而且使用的Hash结构</span></span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                <span class="comment">// 锁不存在 hset获取锁，同时设置过期时间</span></span><br><span class="line">                <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 锁已经存在  </span></span><br><span class="line">                <span class="comment">// 判断锁是否为当前线程，如果是对其值+1,同时再次设置时间(主要解决可重入锁的问题)</span></span><br><span class="line">                <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 都不是则直接返回锁的ttl</span></span><br><span class="line">                <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                <span class="comment">// 下面是三个参数key[1] ARGV[1] ARGV[2] 分别是出传入key，时间，当前线程</span></span><br><span class="line">                <span class="comment">// 这里可以去简单了解下lua的调用语法即可</span></span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在了解<code>key[1] ARGV[1] ARGV[2]</code>是什么后很简单了。</p><p>实际上他为了一个map结构的数据。</p><p>key - 锁的名称<br>filed - 随机字符串+线程ID 值为1<br>value - 线程ID 会随着的递增来实现可重入锁</p><p>加锁基本就已经完成！ 接着来看下解锁</p><h4 id="Redisson解锁的实现"><a href="#Redisson解锁的实现" class="headerlink" title="Redisson解锁的实现"></a>Redisson解锁的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;Void&gt;();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId); <span class="comment">// 解锁的具体方法</span></span><br><span class="line"></span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 锁不存在异常 关闭前面开启的定时任务，抛出异常</span></span><br><span class="line">            cancelExpirationRenewal(threadId);</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁和持锁人不是同一个任务 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            IllegalMonitorStateException cause = <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"attempt to unlock lock, not locked by current thread by node id: "</span></span><br><span class="line">                    + id + <span class="string">" thread-id: "</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁成功 关闭前面开启的定时任务</span></span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line">        result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着直接看解锁的代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lua脚本</span></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 1. 判断锁是否等于当前线程，不等于则返回</span></span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">// 2. 对锁进行递减</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="comment">// &gt;0 则刷新一下过期时间</span></span><br><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="string">"return 0; "</span> +</span><br><span class="line">            <span class="string">"else "</span> +</span><br><span class="line">            <span class="comment">// 不是则删除key，并同时发布锁释放的消息</span></span><br><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span>+</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return nil;"</span>,</span><br><span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redisson的加锁和解锁基本完成。只需要简单的记住它所维护的map数据结构即可很好的记住它的原理</p><h4 id="Redisson中的看门狗"><a href="#Redisson中的看门狗" class="headerlink" title="Redisson中的看门狗"></a>Redisson中的看门狗</h4><p>Redisson有一个看门狗的角色特别说明下，就是前面说的那个定时任务</p><p>首先通过前面的原理已经知道Redis在加锁的时候是会设置一下key的时间的。假如在持有锁的客户端在设置的时间内依然正在执行中，那么就很有可能锁被其他客户端拿到造成两个客户端同时获取到锁。为了解决这个问题才引入了看门狗这个角色。它主要监控获取锁的线程如果该线程一直在运行中，它可以为这个锁的时间来续约。默认是每次续约30000毫秒。</p><p>这个角色具体有兴趣可以自己看下源码。</p><h2 id="ZooKeeper分布式锁"><a href="#ZooKeeper分布式锁" class="headerlink" title="ZooKeeper分布式锁"></a>ZooKeeper分布式锁</h2><p>ZooKeeper的分布式锁首先我们要知道ZooKeeper的基本原理和内存模型。具体可以看我的另外一篇文章，这里不多做介绍了！</p><h3 id="基本原理-Zookeeper"><a href="#基本原理-Zookeeper" class="headerlink" title="基本原理-Zookeeper"></a>基本原理-Zookeeper</h3><h4 id="加锁-ZooKeeper"><a href="#加锁-ZooKeeper" class="headerlink" title="加锁-ZooKeeper"></a>加锁-ZooKeeper</h4><p>加锁主要是通过zookeeper来创建一个临时顺序节点。然后检查自己的节点是否为顺序中最小的那一个，如果不是则监听自己上一个顺序的节点等待被唤醒</p><p>实际就是类似维护了一个FIFO的队列，然后依次监听自己的上一个节点。就像链式结构一样</p><p>这里的临时节点可以保证，自己掉线后，由zookeeper来删除节点，最后通知下一个节点。保证链式不断。</p><h4 id="解锁-ZooKeeper"><a href="#解锁-ZooKeeper" class="headerlink" title="解锁-ZooKeeper"></a>解锁-ZooKeeper</h4><p>解锁就比较简单了。删除自己的节点即可。通过zookeeper的监听机制来通知其他节点</p><h3 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h3><p>既然Redis推荐Redisson，那么ZooKeeper肯定推荐的实现代码！这里推荐curator客户端。同时是基于ZooKeeper做一些开发。可推荐使用该客户端。因为原生客户端不大好用，比如由于ZooKeeper的watch绑定机制每次触发一次就会失效需要重新绑定。这里该客户端已经帮我们实现了动态绑定。避免我们写代码时忘记。详细使用可以自己查看官网了！</p><h4 id="Curator的基本使用"><a href="#Curator的基本使用" class="headerlink" title="Curator的基本使用"></a>Curator的基本使用</h4><p>这里用的版本是2.8.0，其他版本的源码可能有些许出入。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里简单看下使用的代码。非常简单。上面那部分代码可以集成在Spring中。统一使用<code>CuratorFramework</code>即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExponentialBackoffRetry retry = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework framework = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">"192.168.72.253:2181,192.168.72.253:2182,192.168.72.253:2183"</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">50000</span>)</span><br><span class="line">        .connectionTimeoutMs(<span class="number">50000</span>)</span><br><span class="line">        .retryPolicy(retry)</span><br><span class="line">        .namespace(<span class="string">"duteliang"</span>)</span><br><span class="line">        .build();</span><br><span class="line">framework.start();</span><br><span class="line"></span><br><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(framework,<span class="string">"/zl/lock/name"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    interProcessMutex.acquire(); <span class="comment">// 加锁</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    interProcessMutex.release(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Curator加锁的实现"><a href="#Curator加锁的实现" class="headerlink" title="Curator加锁的实现"></a>Curator加锁的实现</h4><p>简单看下<code>internalLock</code>的内部实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 查询缓存是否已经获取到锁了</span></span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="keyword">null</span> ) &#123; <span class="comment">// 已经获取到锁，可重入锁</span></span><br><span class="line">        lockData.lockCount.incrementAndGet(); <span class="comment">// lockCount +1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="comment">// 获取锁成功，添加缓存</span></span><br><span class="line">        LockData newLockData = <span class="keyword">new</span> LockData(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败 返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中重点就是<code>internals.attemptLock</code>获取锁这个方法！继续看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>      startMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> Long      millisToWait = (unit != <span class="keyword">null</span>) ? unit.toMillis(time) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="keyword">null</span>) ? <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">    <span class="keyword">int</span>             retryCount = <span class="number">0</span>;</span><br><span class="line">    String          ourPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         hasTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         isDone = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> ( !isDone )&#123;</span><br><span class="line">        isDone = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建节点, 临时、顺序节点</span></span><br><span class="line">            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">            <span class="comment">// 判断是否获取锁，同时阻塞自己。关键部分</span></span><br><span class="line">            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">        &#125;<span class="keyword">catch</span> ( KeeperException.NoNodeException e )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )&#123;</span><br><span class="line">                isDone = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( hasTheLock )&#123;</span><br><span class="line">        <span class="keyword">return</span> ourPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建节点, 临时、顺序节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String ourPath;</span><br><span class="line">    <span class="keyword">if</span> (lockNodeBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ourPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要就是两步</p><ol><li>创建临时顺序节点</li><li>循环对顺序节点和自己进行检查，来判断自己是否可以获取锁</li></ol><p>接下来看第二部的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> doDelete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这一步是实现可撤销锁的动作，具体还没有研究</span></span><br><span class="line">        <span class="keyword">if</span> (revocable.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环获取锁</span></span><br><span class="line">        <span class="keyword">while</span> ((client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock) &#123;</span><br><span class="line">            List&lt;String&gt; children = getSortedChildren(); <span class="comment">// 获取所有顺序节点，注意已经排序好了。从小到大</span></span><br><span class="line">            String sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// 获取顺序节点的名称</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这一步就不贴源码了，可以自己看下比较简单</span></span><br><span class="line">            <span class="comment">// 主要判断当前节点是否为所有节点的第一个，如果是则获取到锁sTheLock=true, </span></span><br><span class="line">            <span class="comment">// 如果不是则获取到上一个顺序节点的名称</span></span><br><span class="line">            PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            <span class="keyword">if</span> (predicateResults.getsTheLock()) &#123; <span class="comment">// 获取到锁，返回</span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch(); <span class="comment">// 上一个顺序节点的完成名称</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 监听上一个节点、监听内代码在下面有贴。简单的notifyAll代码</span></span><br><span class="line">                        client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                        <span class="keyword">if</span> (millisToWait != <span class="keyword">null</span>) &#123; <span class="comment">// wait 开始阻塞线程等待</span></span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                            startMillis = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (millisToWait &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                doDelete = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            wait(millisToWait);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                        <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        doDelete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doDelete) &#123; <span class="comment">// 如果出现程序异常，则删除自己的节点。</span></span><br><span class="line">            deleteOurPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haveTheLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里补充一下监听的代码。主要做了什么。</span></span><br><span class="line"><span class="comment">// 主要通过 wait 和 notifyAll 的组合来处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyFromWatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，其主要逻辑</p><ol><li>获取所有顺序节点</li><li>判断自己是否为顺序中最小的那个节点，是就获取锁</li><li>不是则获取自己上一个节点，然后watch它。等待唤醒</li></ol><p>这里为了便于理解可以参考一下下面的逻辑图</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-lock-asp.jpg" alt="zookeeper加锁流程图"></p><h4 id="Curator解锁的实现"><a href="#Curator解锁的实现" class="headerlink" title="Curator解锁的实现"></a>Curator解锁的实现</h4><p>解锁就是比较简单了。就是删除节点。不多介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Thread currentThread = Thread.currentThread();</span><br><span class="line">    InterProcessMutex.LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> (lockData == <span class="keyword">null</span>) &#123; <span class="comment">// 当前没有获取到锁。解锁失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"You do not own the lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newLockCount = lockData.lockCount.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (newLockCount &gt; <span class="number">0</span>) &#123; <span class="comment">// 解锁成功</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newLockCount &lt; <span class="number">0</span>) &#123; <span class="comment">// 小于0，程序不正常。抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Lock count has gone negative for lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 删除节点，触发监听器</span></span><br><span class="line">        internals.releaseLock(lockData.lockPath);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除缓存</span></span><br><span class="line">        threadData.remove(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里基本讲完了Redis和ZooKeeper分布式锁的原理和实现。当然了解原理后可以自己去滚轮子，但是要注意很多细节部分。推荐还是直接使用上面的框架。</p><p>那么Redis和ZooKeeper分布式锁，哪个好一点了。</p><p>我认为首先两者在性能上面都是完全能够在生产环境使用的，两者之间的主要区别在于：</p><ol><li>Redis分布式锁上面已经讲过在主从集群环境中，有一个缺点。就是有可能两个客户端同时获取到锁，ZooKeeper就不存在这种。这主要是两者设计理念所造成的。就是我们常说的CAP原则，ZooKeeper保证的是CP（容错性和一致性），而redis保证的是AP（容错性和可用性）。具体可以去了解一下CAP的设计原则。</li><li>ZooKeeper在锁等待时会阻塞线程，不需要通过循环来解决。这也是由于ZooKeeper天然提供watch机制所带来的好处</li><li>ZooKeeper由于CP所带来的强一致性，性能没有redis好，同时由于ZooKeeper的实现中频繁的删除添加节点也有影响。但是ZooKeeper并不慢，只是与Redis比较而言</li></ol><p>所以如果能使用ZooKeeper我还是推荐使用ZooKeeper，但是ZooKeeper在项目中很多时候是作为注册中心来使用（比如dubbo），如果你的项目没有使用ZooKeeper，那么也可以使用Redis来做分布式锁，毕竟大部分项目都会使用Redis来做缓存。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://redis.io/commands/set" target="_blank" rel="noopener">redis官网set命令说明</a><br><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a><br><a href="https://www.jianshu.com/p/47fd7f86c848" target="_blank" rel="noopener">分布式锁之Redis实现</a><br><a href="http://curator.apache.org/curator-recipes/shared-reentrant-lock.html" target="_blank" rel="noopener">curator-lock-document</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分布式锁&quot;&gt;&lt;a href=&quot;#分布式锁&quot; class=&quot;headerlink&quot; title=&quot;分布式锁&quot;&gt;&lt;/a&gt;分布式锁&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
    
      <category term="分布式" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动</title>
    <link href="http://yoursite.com/2019/10/12/framework/SpringBoot%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/10/12/framework/SpringBoot%E5%90%AF%E5%8A%A8/</id>
    <published>2019-10-12T01:58:51.000Z</published>
    <updated>2019-12-31T11:54:13.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot启动"><a href="#SpringBoot启动" class="headerlink" title="SpringBoot启动"></a>SpringBoot启动</h1><p>Spring、SpringBoot启动属于是一个老生常谈的问题，以前整理过也比较碎片化。现重新进行一个整理。由于这个知识工作中用的不多，稍微深入一点太容易遗忘，作为一个长期更新的文档。有时间会更新一部分。<br>同时由于两者对于Spring的启动有很大的共通性，所有主要介绍SpringBoot的启动。毕竟现在新项目基本很少采用Spring Framework了。</p><blockquote><p>这里不想贴太多的源码讲解。不然我会觉得显得文档太长了</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spirng、SpringBoot的启动主要做了什么？</p><p>这个问题大了说，只考虑Spring的话(如果包含容器部分，比如tomcat，还可能设计到Servlet等知识)，其实最主要就是加载Spring Bean。不管是xml、JavaConfig或者是直接申明的Bean，使用FactoryBean加载的Bean。所有的一切都是为了初始化Bean，初始化Bean的时候也就包括了我们启动需要的资源。</p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h2 id="SPI-机制"><a href="#SPI-机制" class="headerlink" title="SPI 机制"></a>SPI 机制</h2><p>在讲解SpringBoot的启动时，首先要了解SPI模式使用。这里我就不详细讲解，主要是一种服务发现机制。可以看看dubbo的开发者文档，因为<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">dubbo</a>中的很多实现也是基于这个来做的。</p><p>只不过SpringBoot的SPI有自己的实现和使用规则，原理都是JAVA自带的SPI类似的。</p><p>SpringBoot是在META-INF的<code>spring.factories</code>文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Application Context Initializers</span></span><br><span class="line"><span class="string">org.springframework.context.ApplicationContextInitializer=\</span></span><br><span class="line"><span class="string">org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\</span></span><br><span class="line"><span class="string">org.springframework.boot.context.ContextIdApplicationContextInitializer,\</span></span><br><span class="line"><span class="string">org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\</span></span><br><span class="line"><span class="string">org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\</span></span><br><span class="line"><span class="string">org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</span></span><br></pre></td></tr></table></figure><p>格式就是上诉的这种方式。ApplicationContextInitializer的6个实现类，注意最后不能加<code>,\</code>。</p><p>SpringBoot在使用SPI的时候一般还会对其进行重排序，我们将接口实现<code>Ordered</code>或者使用注解<code>@Order</code>来决定排序。因为在使用的时候是按顺序调用的。</p><h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebBaseApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(WebBaseApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码就是SpringBoot常用的启动类，按方法分解为两部分，构造函数和执行函数。 先看下构造函数</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ApplicationContextInitializer&lt;?&gt;&gt; initializers;</span><br><span class="line"><span class="keyword">private</span> List&lt;ApplicationListener&lt;?&gt;&gt; listeners;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">"PrimarySources must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// 这里使用SPI获取这两个接口的实现</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    <span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就使用SPI来获取<code>ApplicationContextInitializer</code>和<code>ApplicationListener</code>的实现。以便后面可以使用。除了SPI其实你可以在启动类中用代码去addXXX自己的实现类。也是可以的，毕竟SpringBootApplication也是将它存在一个私有变量中。</p><h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>接下来就是重点了，开始执行run方法。先看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// SPI获取SpringApplicationRunListener接口的实现类</span></span><br><span class="line">    SpringApplicationRunListeners listeners = getRunListeners(args);  </span><br><span class="line">    listeners.starting(); <span class="comment">// 用户自定义</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 初始化environment，也就是配置文件</span></span><br><span class="line">        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        configureIgnoreBeanInfo(environment);</span><br><span class="line">        Banner printedBanner = printBanner(environment);</span><br><span class="line">        <span class="comment">// 创建BeanFactory，这里使用了 AnnotationConfigServletWebServerApplicationContext 这个子类</span></span><br><span class="line">        context = createApplicationContext();</span><br><span class="line">        exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);</span><br><span class="line">        <span class="comment">// 准备上下文</span></span><br><span class="line">        prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 刷新上下文</span></span><br><span class="line">        refreshContext(context);</span><br><span class="line">        <span class="comment">// 上下文刷新后</span></span><br><span class="line">        afterRefresh(context, applicationArguments);</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            <span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        listeners.started(context); <span class="comment">// 用户自定义</span></span><br><span class="line">        callRunners(context, applicationArguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        listeners.running(context); <span class="comment">// 用户自定义</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        handleRunFailure(context, ex, exceptionReporters, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先这里又来一个新的监听器<code>SpringApplicationRunListener</code>,也是通过SPI获取的。他其实是SpringBoot提供的一个接口，会在启动的调用该接口。我们可以通过该接口来在启动的各个阶段加入我们自己的逻辑。这个后面讲。 </p><p>这里就没撒特别的了。</p><ul><li>初始化environment</li><li>创建上下文<code>AnnotationConfigServletWebServerApplicationContext</code></li><li>准备上下文</li><li>刷新上下文</li></ul><p>中间穿插了SpringApplicationRunListener的影子</p><h4 id="prepareContext-准备上下文"><a href="#prepareContext-准备上下文" class="headerlink" title="prepareContext 准备上下文"></a>prepareContext 准备上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareContext</span><span class="params">(ConfigurableApplicationContext context, ConfigurableEnvironment environment,</span></span></span><br><span class="line"><span class="function"><span class="params">        SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;</span><br><span class="line">    context.setEnvironment(environment);</span><br><span class="line">    postProcessApplicationContext(context); <span class="comment">// 对应用上下文进行用户配置的额外处理</span></span><br><span class="line">    applyInitializers(context); <span class="comment">// 执行ApplicationContextInitializer的初始化方法</span></span><br><span class="line">    listeners.contextPrepared(context);  <span class="comment">// 用户自定义</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">        logStartupInfo(context.getParent() == <span class="keyword">null</span>);</span><br><span class="line">        logStartupProfileInfo(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据用户配置，对beanFactory设置一些参数</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">"springApplicationArguments"</span>, applicationArguments);</span><br><span class="line">    <span class="keyword">if</span> (printedBanner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">"springBootBanner"</span>, printedBanner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory) &#123;</span><br><span class="line">        ((DefaultListableBeanFactory) beanFactory)</span><br><span class="line">                .setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazyInitialization) &#123;</span><br><span class="line">        context.addBeanFactoryPostProcessor(<span class="keyword">new</span> LazyInitializationBeanFactoryPostProcessor());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Load the sources</span></span><br><span class="line">    Set&lt;Object&gt; sources = getAllSources();</span><br><span class="line">    Assert.notEmpty(sources, <span class="string">"Sources must not be empty"</span>);</span><br><span class="line">    load(context, sources.toArray(<span class="keyword">new</span> Object[<span class="number">0</span>]));</span><br><span class="line">    listeners.contextLoaded(context); <span class="comment">// 用户自定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备上下文，就是在整个上下文（ApplicationContext）、配置文件（Enviroment）等资源文件。</p><p>这里有个<code>applyInitializers(context)</code>就是执行最开始构造函数通过SPI拿到的<code>ApplicationContextInitializer</code>实现类。主要就是在刷新上下文指定一些自定义的代码。比如对配置文件的处理。</p><h4 id="刷新上下文"><a href="#刷新上下文" class="headerlink" title="刷新上下文"></a>刷新上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里基本就是Bean的加载了。也就是IOC的主要部分。 找到一篇比较详细的文章推荐下! <a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Spring-IOC</a></p><h3 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h3><p>ApplicationListener是Spring Framework中的类。典型的观察者模式，我们可以在实现他对在Spring的启动，关闭等各个环节开启一个监听器。在设计模式中作为例子讲解一下</p><h3 id="SpringApplicationRunListeners"><a href="#SpringApplicationRunListeners" class="headerlink" title="SpringApplicationRunListeners"></a>SpringApplicationRunListeners</h3><p>SpringApplicationRunListeners是SpringBoot中的类。它相当于SpringBoot开放的一个钩子函数。我们实现它，SpringBoot在启动的各个环节都会去执行该接口。我们可以在SpringBoot启动中加入自己的逻辑</p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>其实看完上面的简单启动版本。其实有时候会在想实际开发中怎么用？ 下面简单说明一下</p><h3 id="EnableAutoConfiguration、Condition接口"><a href="#EnableAutoConfiguration、Condition接口" class="headerlink" title="@EnableAutoConfiguration、Condition接口"></a>@EnableAutoConfiguration、Condition接口</h3><p>这两个其实才是实际框架集成到SpringBoot开发中用的最多的。</p><p>EnableAutoConfiguration具体实现可以看这篇文章，很不错的。<a href="https://www.cnblogs.com/xiaoxi/p/7999885.html" target="_blank" rel="noopener">EnableAutoConfiguration</a>。</p><p>套用里面的一句话：@EnableAutoConfiguration也是借助@Import的帮助，将所有符合自动配置条件的bean定义加载到IoC容器，仅此而已！</p><p>这才是我们需要的重点将我们定义的Bean加载到Spring</p><p>那Condition是干什么的了？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition是Spring Framework中一直都存在的一个接口(具体哪个版本开始就不清楚了)。SpringBoot将它发扬光大了对其做了很多实现</p><p>该接口和@Bean，@Component配合使用来决定Bean是否需要加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当配置 com.myConfig.one 有 true时则启动该Bean</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(value = <span class="string">"com.myConfig.one"</span>,havingValue = <span class="string">"true"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存在当 OtherBean 存在Spring中就加载我们的Bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean</span>(OtherBean<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">MyConfigBean</span> <span class="title">myConfigBean</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyConfigBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个简单的例子。该注解就可以灵活的控制我们的Bean的加载情况。</p><blockquote><p>到此SpringBoot启动先做了一个简单的介绍整理。主要是因为在我查看了自己以前写的文档后。发现过于碎片化和无脑贴代码。觉得没什么意义，还不如很多网上已有的文档好。所以就直接剔除了。文档中也贴了两个写的可以的文档。后面有时间在整理这部分！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot启动&quot;&gt;&lt;a href=&quot;#SpringBoot启动&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot启动&quot;&gt;&lt;/a&gt;SpringBoot启动&lt;/h1&gt;&lt;p&gt;Spring、SpringBoot启动属于是一个老生常谈的问
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot,Spring" scheme="http://yoursite.com/tags/SpringBoot-Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot打包分离资源文件</title>
    <link href="http://yoursite.com/2019/09/12/framework/SpringBoot%E6%89%93%E5%8C%85%E5%88%86%E7%A6%BB%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/09/12/framework/SpringBoot%E6%89%93%E5%8C%85%E5%88%86%E7%A6%BB%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/</id>
    <published>2019-09-12T01:58:51.000Z</published>
    <updated>2019-12-31T11:54:13.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot打包分离资源文件"><a href="#SpringBoot打包分离资源文件" class="headerlink" title="SpringBoot打包分离资源文件"></a>SpringBoot打包分离资源文件</h1><p>SpringBoot使用内置tomcat打包会非常简单，但是默认的SpringBoot的maven插件打包会将所有三方jar和配置文件打包成一个jar。但是在个人或者公司需要做一些小项目或者工具之类的，需要将三方jar包和配置文件分离。就需要利用maven插件来做打包了</p><h2 id="SpringBoot打包"><a href="#SpringBoot打包" class="headerlink" title="SpringBoot打包"></a>SpringBoot打包</h2><p>先来看下SpringBoot的插件的打包代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.web.Application<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将三方jar打入jar中--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码比较简单，不多介绍。</p><h2 id="maven-jar-plugin"><a href="#maven-jar-plugin" class="headerlink" title="maven-jar-plugin"></a>maven-jar-plugin</h2><p>我使用的assembly打包的方式，当然方法肯定不止一种，由于这种成功了，就没有去尝试其他了。</p><p>在使用这种插件的时候先要接触另外一种插件maven-jar-plugin，这个插件主要目的是将主项目打包成jar，而且指定jar的资源路径（实际就是配置_MANIFEST.MF文件_）。可以查看官网地址！有详细说明。<a href="http://maven.apache.org/shared/maven-archiver/" target="_blank" rel="noopener">链接</a>直接看我的代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.scxx.web.ScxxApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--是否添加依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--路径项目前缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MANIFEST.MF Class-Path 加入资源文件目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Class-Path</span>&gt;</span>./<span class="tag">&lt;/<span class="name">Class-Path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>application-*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>config/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>build/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>插件主要做的事情就是打包主项目jar，指定class-path路径。同时过滤掉不想打入jar包的文件。这样jar包就ok了。我们看下META-INF资源文件写了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: web</span><br><span class="line">Implementation-Version: 0.0.1</span><br><span class="line">Archiver-Version: Plexus Archiver</span><br><span class="line">Implementation-Vendor-Id: com.scxx.tool</span><br><span class="line">&#x2F;&#x2F; 注意的 .&#x2F; 实际就是上面配置的Class-path</span><br><span class="line">Class-Path: .&#x2F; lib&#x2F;test-0.0.1.jar lib&#x2F;base-0.0.1.jar *** (lib文件很多，我过滤掉了)</span><br><span class="line">Created-By: Apache Maven 3.6.1</span><br><span class="line">Build-Jdk: 1.8.0_131</span><br><span class="line">Implementation-URL: https:&#x2F;&#x2F;projects.spring.io&#x2F;spring-boot&#x2F;#&#x2F;spring-bo</span><br><span class="line"> ot-starter-parent&#x2F;kit&#x2F;web</span><br><span class="line">Main-Class: com.web.Application</span><br></pre></td></tr></table></figure><h3 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="maven-assembly-plugin"></a>maven-assembly-plugin</h3><p>接下来开始使用maven-assembly-plugin插件做压缩和资源整理。官网<a href="http://maven.apache.org/plugins/maven-assembly-plugin/" target="_blank" rel="noopener">链接</a>  </p><p>直接看代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- not append assembly id in release file name --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/resources/build/release.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>很普通，因为重点不是不在这里，主要在他指定的release.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>dist<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">format</span>&gt;</span>tar.gz<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includeBaseDirectory</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeBaseDirectory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencySets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 排除自己的jar，因为这里我已经将他放在外面了--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">useProjectArtifact</span>&gt;</span>false<span class="tag">&lt;/<span class="name">useProjectArtifact</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 资源文件路径,注意和上面的lib路径对应 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unpack</span>&gt;</span>false<span class="tag">&lt;/<span class="name">unpack</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencySets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 把项目相关的执行文件和说明文件，打包进压缩文件的根目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 项目路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/build<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 输出到zip的路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>./<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.txt<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>bin/**<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 把项目相关的db文件，打包进压缩文件的根目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/db<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>./db<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 把项目的基本配置文件，打包进压缩文件的根目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-release.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>application-business.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 把项目自己编译出来的jar文件，打包进压缩文件的根目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处主要理解<code>fileSet</code>的使用即可。将自己需要的文件要按路径打包压缩文件中! 需要注意的点都已经写在里面了。每个人可以根据自己的需求来制定自己的打包方式。</p><p>也可以参考这个项目的打包方式！<a href="https://github.com/dute7liang/kit" target="_blank" rel="noopener">链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot打包分离资源文件&quot;&gt;&lt;a href=&quot;#SpringBoot打包分离资源文件&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot打包分离资源文件&quot;&gt;&lt;/a&gt;SpringBoot打包分离资源文件&lt;/h1&gt;&lt;p&gt;Spring
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot,Maven" scheme="http://yoursite.com/tags/SpringBoot-Maven/"/>
    
  </entry>
  
  <entry>
    <title>Bean的生命周期</title>
    <link href="http://yoursite.com/2019/09/12/framework/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2019/09/12/framework/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2019-09-12T01:58:51.000Z</published>
    <updated>2019-12-31T11:54:13.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>讲解Bean的生命周期之前，要先了解一下IOC的基础原理。重点在Refresh方法。可以查看这个<a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">博客</a>。我觉得写的很详细了。</p><p>我再对其做一个Bean的生命周期的补充</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li>构造函数</li><li>参数的注入，依赖注入</li><li>调用实现<code>*Aware</code>的接口的方法，顺序依次是：BeanNameAware、BeanFactoryAware、ApplicationContextAware</li><li>调用实现<code>BeanPostProcessor</code>接口的初始化方法</li><li>调用bean的初始化方法，initMethod（注解@PostConstruct）</li><li>调用接口<code>InitializingBean</code>的afterPropertiesSet方法</li><li>调用<code>BeanPostProcessor</code>的初始化之后的方法</li><li>Bean的销毁</li></ol><p>基本就这些步骤</p><blockquote><p>网上还有更多的详细步骤，有兴趣的可以自己去了解一哈，我有时间也会在总结一下</p></blockquote><p>在我们使用Bean的时候。如果对Bean进行增强扩展。其实这些就已经足够。还有很多Bean的生命周期的调用Spring自己在处理的过程中的内部使用，不推荐我们去继承或者实现使用</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>其实在正常的情况第一步和第二步感觉已经足够，为什么还有后面这么多步骤？其实全部都是为了Bean的增强处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDemo</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">ApplicationContextAware</span> , <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDemo2 beanDemo2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanDemo2</span><span class="params">(BeanDemo2 beanDemo2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanDemo2 = beanDemo2;</span><br><span class="line">        log.warn(<span class="string">"BeanDemo 的注入！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"name"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String age = <span class="string">"age"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        log.warn(<span class="string">"BeanDemo的静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        log.warn(<span class="string">"BeanDemo的构造方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"BeanDemo的无参构造函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        log.warn(<span class="string">"调用 BeanNameAware 方法,name=&#123;&#125;"</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"调用 BeanFactoryAware 方法,beanFactory=&#123;&#125;"</span>,beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        beanDemo2 = <span class="keyword">null</span>;</span><br><span class="line">        log.warn(<span class="string">"调用 ApplicationContextAware 方法,注入ApplicationContext "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"调用 afterPropertiesSet 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.warn(<span class="string">"调用 initMethod 初始化方法 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        log.warn(<span class="string">"调用 destroyMethod 销毁方法 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> BeanDemo)&#123;</span><br><span class="line">            log.warn(<span class="string">"调用BeanPostProcessor 的初始化之前方法,Bean=&#123;&#125;"</span>,bean.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> BeanDemo) &#123;</span><br><span class="line">            log.warn(<span class="string">"调用BeanPostProcessor 的初始化之后方法,Bean=&#123;&#125;"</span>, bean.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个普通的Bean。当我们创建这个Bean的时候日志打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : BeanDemo的静态方法</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : BeanDemo的构造方法</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : BeanDemo的无参构造函数</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : BeanDemo 的注入！</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : 调用 BeanNameAware 方法,name&#x3D;beanDemo</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : 调用 BeanFactoryAware 方法</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : 调用 ApplicationContextAware 方法,注入ApplicationContext </span><br><span class="line">WARN 7428 --- [           main] c.d.webbase.bean.MyBeanPostProcessor     : 调用 BeanPostProcessor 的初始化之前方法,Bean&#x3D;BeanDemo(beanDemo2&#x3D;null, name&#x3D;beanDemo, age&#x3D;age)</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : 调用 initMethod 初始化方法</span><br><span class="line">WARN 7428 --- [           main] com.duteliang.webbase.bean.BeanDemo      : 调用 afterPropertiesSet 方法</span><br><span class="line">WARN 7428 --- [           main] c.d.webbase.bean.MyBeanPostProcessor     : 调用 BeanPostProcessor 的初始化之后方法,Bean&#x3D;BeanDemo(beanDemo2&#x3D;null, name&#x3D;beanDemo, age&#x3D;age)</span><br></pre></td></tr></table></figure><h3 id="Aware接口"><a href="#Aware接口" class="headerlink" title="Aware接口"></a>Aware接口</h3><p>Aware用的并不多,我再工作中并没有发现使用的时候。有使用场景的时候在补充吧</p><h3 id="BeanPostProcessor-接口"><a href="#BeanPostProcessor-接口" class="headerlink" title="BeanPostProcessor 接口"></a>BeanPostProcessor 接口</h3><p>BeanPostProcessor就是一个比较实用的东西<br>你可以拿它去修改一些框架的Bean，如果Bean有时候并不如满足你的要求，但是你又不想去重写他整个部分只为修改一小部分（尤其是一些框架内部的bean）。你就可以使用它来对Bean进行增强处理<br>你可以拿它去对你的Bean添加代理，对Bean做一些监控。</p><h3 id="初始化方法-PostConstruct"><a href="#初始化方法-PostConstruct" class="headerlink" title="初始化方法 @PostConstruct"></a>初始化方法 @PostConstruct</h3><p>也比较实用，你可以在启动的时候对你的Bean做一些资源处理。可以在此加入你的逻辑</p><h3 id="afterPropertiesSet"><a href="#afterPropertiesSet" class="headerlink" title="afterPropertiesSet"></a>afterPropertiesSet</h3><p>这个倒是用的不多，可以去检验Bean的参数?</p><h2 id="FactoryBean的使用"><a href="#FactoryBean的使用" class="headerlink" title="FactoryBean的使用"></a>FactoryBean的使用</h2><p>这里稍微讲解一下FactoryBean的部分</p><p>FactoryBean顾名思义其实就是一个Bean。可以理解为一个特殊的Bean。注意别把他和BeanFactory搞混了就行</p><p>直接看看这货的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 可以不写该注解，直接在xml中配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">MyBean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyBean <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 加入你的复杂的逻辑判断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;MyBean&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MyBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是FactoryBean的使用,可以理解为他相当于实际Bean的代理类。</p><p>这货有什么实际用处了？本人在开发中，其实主要在XMl时代是个神器可以解决很多普通xml无法解决的问题。  </p><p>举个例子：比如我在实际开发中，redis,mongodb的连接。尤其环境的不一致，公司开发由于机器不够可能用的单机。云上生产环境肯定是用了副本集或者分片。在连接代码肯定是不一样的。xml很难去解决这个问题（当然你在xml中开启注解扫描，直接使用@Configuration也可以，为了统一性。有时候不会做）。</p><p>这时候FactoryBean的作用就来了。你可以在XMl中配置FactoryBean。在其代码中直接通过对配置的参数自动选择使用单机或者副本集或者分片等等。</p><p>不过现在新项目采用SpringBoot以后xml基本被抛弃，使用代码创建Bean本身灵活性就很大，这种问题也不存在。后面倒是没怎么用过了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bean的生命周期&quot;&gt;&lt;a href=&quot;#Bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Bean的生命周期&quot;&gt;&lt;/a&gt;Bean的生命周期&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring,Bean" scheme="http://yoursite.com/tags/Spring-Bean/"/>
    
  </entry>
  
  <entry>
    <title>J.U.C</title>
    <link href="http://yoursite.com/2019/05/20/javabase/J.U.C/"/>
    <id>http://yoursite.com/2019/05/20/javabase/J.U.C/</id>
    <published>2019-05-20T01:58:51.000Z</published>
    <updated>2019-12-31T11:50:48.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先我们要编写一些代码的例子，以便更好测试和理解哪个操作是线程安全，那些操作不是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> requestTotal = <span class="number">8000</span>;</span><br><span class="line">    <span class="comment">// 线程总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 共享变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(requestTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requestTotal; i++) &#123;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    log.error(<span class="string">"error"</span>,e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        log.info(<span class="string">"共享变量数：&#123;&#125;"</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主要关注的点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码就是利用多线程执行 <code>count++</code> 操作！<br>很明显执行后的结构肯定是小于八千的，主要原因是count++这个操作并非原子性。多线程会影响其count的取值。</p><h2 id="Atomic-包"><a href="#Atomic-包" class="headerlink" title="Atomic 包"></a>Atomic 包</h2><p>Atomic包里面有很多基本类型的线程安全类，当我们把上诉代码中的Int缓存AtomicInteger此代码就是线程安全的。<br>看下源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>关键代码是native修饰，并不是由java实现。但是从这简单的代码，我第一次看到就猜到了这不就是乐观锁么。事实也确实如此。compareAndSwapInt 方法就是在作比较成功就交换的动作。一只不断尝试。所以Atomic包下的类基本就是利用这种CAS无锁操作。来实现并发支持。理论上这种循环都是很快就能够完成的。比锁的效率要高。<br>不建议在有大量更新的情况下使用。更多的是作为一些状态的标记来使用。</p><p>其他的Atomic包下的类有：</p><ul><li>AtomicLong  LongAdder</li><li>ActomicBoolean</li><li>ActomicReference</li><li>ActomicIntegerFieldUpdate  更新某个类的字段 字段必须是volatile</li><li>ActomicStampReference  CAS的ABA的问题</li></ul><p>就先不多做介绍了。</p><h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p>我们都知道我们常用的ArrayList、LinkedList都不是线程安全的，并发情况下会出现数据BUG。<br>那有哪些List是线程安全的了？</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>vector并不是J.U.C下的包。但是他确实是一个线程安全的集合和ArrayList一样，底层都是由数组实现。不同的是它的基本所有的方法都加了synchronized加锁，以保证线程的安全性。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>stack也不是J.U.C下的包。他是一个线程安全的集合。和Vector一样也是加了synchronized保证线程安全性。stack是一个算法中常用的模型。基于FILO原则。</p><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>J.U.C下的并发类，简单看下它的部分内部源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// copy一个新数组</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点在add方法，首先利用ReentrantLock这种独占锁保持线程安全。在add操作时，先copy一份数组出来，更新后在写会原数据。这种方式保证了读取的效率。读数据不会受写数据的影响。但是这中缺点也比较明显。</p><ol><li>保证了最终一致性，但是实时性比较差</li><li>由于每次更新都要copy一次整个数据，对于数据量偏大的数据容器引起YGC、FGC的操作。</li></ol><p>所以这个比较适合数据量不大，读多写少，而且实时性安全不是很严格的情况下。该数据实际使用的情况不多。</p><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>底层使用了CopyOnWriteArrayList来实现，唯一的区别就是List和Set的区别。</p><h3 id="ConcurrentSkipListMap、ConcurrentSkipListSet"><a href="#ConcurrentSkipListMap、ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListMap、ConcurrentSkipListSet"></a><br />ConcurrentSkipListMap、ConcurrentSkipListSet</h3><p>ConcurrentSkipListMap底层采用了一种跳表的数据形式，实际是一种链表。底层通过CAS的方式保证了线程安全性。 ConcurrentSkipListSet底层使用了ConcurrentSkipListMap来实现<br>注意两者都不支持null的处理，同时对于addAll等批量操作，不能保证安全性。只能保证单数据操作的安全性</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>用的最多的并发类，可以查看其他文档。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Collections.synchronizedXXX:collection、List、Set、Map</p><p>我们可以通过Collections工具类来直接生成一个线程安全的集合，实现比较简单，通过synchronized关键字来保证线程安全</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;J-U-C&quot;&gt;&lt;a href=&quot;#J-U-C&quot; class=&quot;headerlink&quot; title=&quot;J.U.C&quot;&gt;&lt;/a&gt;J.U.C&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://yoursite.com/2019/05/12/javabase/Servlet/"/>
    <id>http://yoursite.com/2019/05/12/javabase/Servlet/</id>
    <published>2019-05-12T04:32:42.000Z</published>
    <updated>2019-12-31T11:53:41.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Servlet在我工作中其实是一个每天都要接触的东西，毕竟是搞Java Web的。但是Tomcat、Spring MVC都已经帮我们做好了所有的东西，所以我们在用的时候，只是简单的写了Class，再写个注解就能使用了。所以属于比较容易遗忘的东西。这里就简单的讲解一下什么是Servlet，我个人认为也没有必要弄得非常深和全面(其实我也没有那个技术)，毕竟别人都滚好轮子了。我们用就是了，但是还是要理解一下其中原理。遇到问题也好查找原因。</p><h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>Servlet在Java Web开发中每天打交道的一个东西，它是什么？简单的说我认为它只是一个规范、一个接口，就像BeanFactory一样定义的规范类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是Servlet的接口规范。其实很简单。依次说下每个方法的作用，我们就能了解Servlet是干什么的</p><ul><li>init 初始化servlet 其实就是我们经常配的<code>&lt;init-params&gt;</code>，有了他我们才能知道这个Servlet对应哪个请求，找准自己的定位</li><li>getServletConfig 不讲了，没撒用，获取配置</li><li>service 处理请求，</li><li>getServletInfo get方法没撒好说的</li><li>destory 销毁servlet</li></ul><p>所以上面可以看出其实Servlet主要就规范了3个东西，接受请求、处理请求、响应请求。</p><p>那么Servlet这么简单。我们就实现一个Servlet是不是就可以用了？不行！这只是一个规范，所以还需要一个容器来管理Servlet。请求来了帮我们找到指定的Servlet。比如我们最最最常用的Tomcat（所以Tomcat也可以说是一个Servlet容器）。其实这里有点像Spring和Bean之间的关系。</p><h2 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h2><p>讲了Servlet，那我们到底怎么使用。这里就引入了HttpServlet。毕竟Servlet这个接口太抽象了。我们不好用，所以他就有了模板类，就是我们经常会用到的模板方法模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: zl</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/12/9 23:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException</span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServlet实现了Servlet接口（中间还有一个抽象类，你可以理解它对Servlet又做一步实现的扩充），也把能做的事情都做了。留了doXXX接口给我们实现。让我们写自己的逻辑请求。上面就是我们常用的Servlet的实际写法。其实我们还要配置ServletConfig，不然这个Servlet都不知道自己是谁。比如可以在Web.xml中配置初始化的基本参数</p><blockquote><p>至于请求是怎么进入Servlet的，这个到SpringBoot的启动里面讲一下，因为SpringBoot是内嵌Tomcat，所以看源码比较好看一点。而且好理解。</p></blockquote><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet的生命周期很多时候面试可能都会去问，其实当简单看懂上面的说明后加上一些工作经验和猜测，就可以简单的猜出它的生命周期了。</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/base/servlet/servlet-shengmingzhouqi.jpg" alt="servlet生命周期"></p><ol><li>客户端发起Http请求</li><li>容器去解析请求</li><li>创建Servle,注意这里其实是有Tomcat容器肯定不会每次都初始化，在第一次初始化会将这个Servlet保存在内存中，下次请求就可以直接使用了</li><li>调用Init方法，初始化请求</li><li>调用Servce方法，响应请求</li><li>输出响应信息，一般会帮我们封装成Response</li><li>调用destory()方法，由于Servlet会驻留在内存中。一般情况是tomcat容器关闭会去调用destory方法</li></ol><h2 id="Jsp和Servlet"><a href="#Jsp和Servlet" class="headerlink" title="Jsp和Servlet"></a>Jsp和Servlet</h2><p>说到Servle还是必须说明一下Jsp。Jsp是在Servlet后面出现的。主要是因为Servlet在对返回Html页面的时候不是很友好，所以才有了Jsp。<br>所以我们可能都知道Jsp其实就是一个Servlet</p><p>其实我们在访问一个Jsp的时候，它在第一次访问的时候。会将Jsp编译成一个Java类，这个类是继承也是HttpServlet的。</p><p>比如自己可以做个测试环境<br>做一个简单jsp</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    hello world</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>当我们调用通过url获取jsp页面时，其实已经讲Jsp编译成Class，实际上就是执行Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.jsp.WEB_002dINF.jsp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">hello_jsp</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">HttpJspBase</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceDependent</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceImports</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br><span class="line">        pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">        _jspx_page_context = pageContext;</span><br><span class="line">        application = pageContext.getServletContext();</span><br><span class="line">        config = pageContext.getServletConfig();</span><br><span class="line">        session = pageContext.getSession();</span><br><span class="line">        out = pageContext.getOut();</span><br><span class="line">        _jspx_out = out;</span><br><span class="line">        out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"&lt;!DOCTYPE html&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"&lt;html lang=\"en\"&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"&lt;head&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"    &lt;meta charset=\"UTF-8\"&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"    &lt;title&gt;Title&lt;/title&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"&lt;/head&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"&lt;body&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"    hello world\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"&lt;/body&gt;\r\n"</span>);</span><br><span class="line">        out.write(<span class="string">"&lt;/html&gt;"</span>);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只断断续续的贴了一部分。其中HttpJspBase的基本关系：<code>public abstract class HttpJspBase extends HttpServlet implements HttpJspPage</code>，可以看到其实也是继承了HttpServlet，那他是怎么把html给客户端的，可以看到实际也就是通过<code>write()</code>写出去。其实和我们一样的。</p><p>不过Jsp相对于Servlet好用的一点是，它内置了9个对象：out、session、response、request、config、page、application、pageContext、exception我们可以直接在jsp中使用（其实我用的很少，主要也就获取一个项目根路径，然后el表达式基本够用）。</p><p>Jsp也就基本结束了</p><blockquote><p>题外话，为了测试演示了一下，用SpringBoot搞一个Jsp环境好多坑，也确实SpringBoot其实对Jsp不怎么友好，如果没有前后端分离想使用页面，还是推荐它默认的thymeleaf</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Servlet&quot;&gt;&lt;a href=&quot;#Servlet&quot; class=&quot;headerlink&quot; title=&quot;Servlet&quot;&gt;&lt;/a&gt;Servlet&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaEE,Servlet" scheme="http://yoursite.com/tags/JavaEE-Servlet/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2019/04/25/javabase/HashMap/"/>
    <id>http://yoursite.com/2019/04/25/javabase/HashMap/</id>
    <published>2019-04-25T01:58:51.000Z</published>
    <updated>2019-12-31T11:50:48.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="1-何为hash"><a href="#1-何为hash" class="headerlink" title="1. 何为hash"></a>1. 何为hash</h2><p>简单的说hash可直接理解为一个数组，区别在于其下标是通过hash算法来算出来的，一个好的算法能够使数据分配的更加均匀。但是不管多好的算法。总会发生不同的数据算出一样的hash值，这样就会发生hash碰撞，hashMap的解决办法是在发生hash碰撞的地址继续通过链式结构来组装，这其实就是HashMap的基本结构了！</p><h2 id="2-HashMap中的基本变量"><a href="#2-HashMap中的基本变量" class="headerlink" title="2. HashMap中的基本变量"></a>2. HashMap中的基本变量</h2><p>本次主要以JDK8为准，和7的区别主要是引入了红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容器大小,必须是2的倍数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">// 最大的容器大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 扩容因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先了解一下它的结构体，里面存了一个hash，key实际就HashMap中的key，value也就是我们实际的数据，next是为了链式而准备的。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验数据准确性</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 获取调整容器的大小阈值，initialCapacity*loadFactor</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的过程比较简单，就是计算和校验了需要准备的参数，其中有个扩容因子，可以理解为当实际数据达到容器的多少比例就需要扩容处理。</p><h2 id="4-添加数据"><a href="#4-添加数据" class="headerlink" title="4. 添加数据"></a>4. 添加数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际存放</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// table为null，则初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 由于n为2的整数，所以n-1的二进制尾数都为1</span></span><br><span class="line">        <span class="comment">// 这里实际是获取hash在n的数组内的下标</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 该下标没有数据，则新增</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该下标有数据，说明发生hash碰撞</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">// 判断key值是否相等，相等直接替换value</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">// 判断p是否是TreeNode是则走红黑树的判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">// 走正常的链表判断</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">// 将数据添加到链表结尾</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">// 这里要判断链表转红黑树的阈值，默认是8</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// key只相等，说明是update操作</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里e!=null表示是update操作，这里没有做任何处理</span></span><br><span class="line">            <span class="comment">// 留了个钩子函数，给LinkedHashMap做继承使用</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">// 如果数量大于容器阈值，则需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 同样没有处理，给LinkedHashMap做继承使用</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>走完代码！逻辑其实已经很清晰。还需要看一下resize主要是怎么扩容的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 表示容器已经初始化，试一次扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">//到达容器的极限</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 未到达容器极限，数量乘以2</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                        oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里表示初始化时，给了自定义的参数,阈值已提前算好</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">// 初始化是默认的，直接取默认的</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 上面只解决了newCap没有处理newThr，这里处理</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                        (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 上面代码已经解决了初始化和扩容参数问题，这里主要解决实际的数据迁移问题</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>resize其实就是对数据的初始化和2倍扩容操作。</p><h2 id="5-Remove操作"><a href="#5-Remove操作" class="headerlink" title="5. Remove操作"></a>5. Remove操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">// 判断下标是否存在数据</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">// 下标中的第一个数据就相等</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">// 数据可能在链表或者红黑树中，在深入查找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到数据，对数据进行删除</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="6-结语"><a href="#6-结语" class="headerlink" title="6. 结语"></a>6. 结语</h2><p>通过对HashMap的基本操作理解，其实可以大概知道了HashMap的基本元素！数组+链表or红黑树。<br>红黑树由于还没有研究，所以这里我直接跳过了，有需要可以在去深入理解一下。<br>所以这里知道对HashMap而言，增加性能的方法有：</p><ol><li>减少Hash碰撞</li><li>减少扩容操作</li></ol><p>其实1不是很好操作，对于2需要的仅仅只是在创建Map的时候对于已知的数据大小，要尽量给出初始化的容器大小，避免频繁的自动扩容！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap&quot;&gt;&lt;a href=&quot;#HashMap&quot; class=&quot;headerlink&quot; title=&quot;HashMap&quot;&gt;&lt;/a&gt;HashMap&lt;/h1&gt;&lt;h2 id=&quot;1-何为hash&quot;&gt;&lt;a href=&quot;#1-何为hash&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Map" scheme="http://yoursite.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Java线程和线程池</title>
    <link href="http://yoursite.com/2019/04/19/javabase/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://yoursite.com/2019/04/19/javabase/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2019-04-19T01:58:51.000Z</published>
    <updated>2019-12-31T11:50:48.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程和线程池"><a href="#线程和线程池" class="headerlink" title="线程和线程池"></a>线程和线程池</h1><h2 id="1-何为线程"><a href="#1-何为线程" class="headerlink" title="1. 何为线程"></a>1. 何为线程</h2><p>简单的理解就是一个进程里的细致划分，我们正常的软件只会占用一个进程，但是为了更好的榨干cpu的性能，可以将进程分为多个线程，实际处理工作的是线程！</p><h2 id="2-线程的状态"><a href="#2-线程的状态" class="headerlink" title="2. 线程的状态"></a>2. 线程的状态</h2><p><img src="https://cdn.nlark.com/yuque/0/2019/png/440120/1566453208678-b2353609-de4d-4566-bf3d-a42fd7b51914.png#align=left&display=inline&height=375&name=&originHeight=375&originWidth=554&size=0&status=done&width=554" alt="image"></p><p>java中线程的状态</p><ol><li>新建状态：调用new，还没有启动开始代码执行！</li><li>就绪状态：对象已经准备好，但是还没有开始执行run</li><li>运行状态：执行run方法后，程序正常执行</li><li>阻塞状态：线程因为各种原因进入阻塞，而让出CPU资源的状态<ul><li>sleep<br>程序调用<code>Thread.sleep(xx)</code>后，线程释放CPU资源，但是没有释放锁资源</li><li>wait<br>程序调用wait后，线程释放CPU资源和锁资源，注意wait只有在锁内才能调用，否则会抛出<code>IllegalMonitorStateException</code>异常！  </li><li>IO or 调用其他同步方法<br>其他原因就是程序在调用IO或者其他同步的方法时，调用者处于休眠状态时！</li></ul></li><li>死亡状态：线程进入死亡状态<br>正常执行完成后进入死亡状态或者在遇到异常后中断程序进入死亡状态</li></ol><h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h2><p>池这技术，我们会经常遇到，比如jdbc会遇到连接池，目的都是差不多，主要是更好的管理这些单位的创建和死亡。线程池也是为了更好管理线程的创建与销毁动作！</p><h3 id="3-1-ThreadPoolExecutor"><a href="#3-1-ThreadPoolExecutor" class="headerlink" title="3.1 ThreadPoolExecutor"></a>3.1 ThreadPoolExecutor</h3><p>java中自带线程池的线程池有四种：<strong>可缓存线程池</strong>，<strong>定长线程池</strong>，<strong>单线程池</strong>，还有一个<strong>支持简单定时调度的线程池</strong>。这些线程池不需要记。通过源码其实可以看到他们都是调用通一个构造函数。所以我们只需要理解这个构造函数的原理即可，很多团队也都是直接调用该构造函数来创建线程池，这样可以直观的理解创建线程池的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的创建线程池的构造函数，简单说明一下每个参数的含义:</p><ul><li>corePoolSize   核心线程数量</li><li>maximumPoolSize  最大线程数量</li><li>keepAliveTime 线程活跃保存时间，如果创建的线程大于核心线程数量的清除动作！</li><li>unit  上面这个参数的时间单位</li><li>workQueue  阻塞队列，存放等待的队列</li><li>threadFactory  线程工厂，用来创建线程</li><li>handler  驳回策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">// 1.如果当前活跃线程小于核心线程数量，直接执行线程</span></span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 2. 尝试将线程加入阻塞队列，如果加入成功！后面再次检查了一下是否加入成功！</span></span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 3. 再次尝试启动队列,但是不能超过最大线程数</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面的逻辑，已经可以了解核心参数的基本含义了！<br>源码y有更加深入的了解可以查看这篇文章了, <a href="https://blog.csdn.net/programmer_at/article/details/79799267#421-execute%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">链接</a></p><p>参数的基本逻辑为：</p><ol><li>判断核心线程数，小于则启动线程</li><li>判断阻塞队列，</li><li>判断最大线程数</li><li>驳回策略</li></ol><h3 id="3-2-阻塞队列"><a href="#3-2-阻塞队列" class="headerlink" title="3.2 阻塞队列"></a>3.2 阻塞队列</h3><p>阻塞队列BlockingQueue，Java提供了几种实现！</p><ol><li>ArrayBlockingQueue  基于数组的有界阻塞队列，FIFO</li><li>LinkedBlockingQueue  基于链式的有界阻塞队列，FIFO</li><li>SynchronousQuene  不存储元素的阻塞队列，每次插入都要等上一个节点移除</li><li>PriorityBlockingQuene  具有优先级的无界阻塞队列</li></ol><blockquote><p>LinkedBlockingQueue比ArrayBlockingQueue在插入删除节点性能方面更优，但是二者在put(), take()任务的时均需要加锁，SynchronousQueue使用无锁算法，根据节点的状态判断执行，而不需要用到锁，其核心是Transfer.transfer().</p></blockquote><h3 id="3-3-驳回策略"><a href="#3-3-驳回策略" class="headerlink" title="3.3 驳回策略"></a>3.3 驳回策略</h3><p>驳回策略，Java也提供了几种实现！</p><ol><li>AbortPolicy  直接抛出异常，默认</li><li>CallerRunsPolicy  用调用者所有线程，执行任务</li><li>DiscardOldestPolicy  丢弃阻塞队列中最靠前的任务，来执行该任务</li><li>DiscardPolicy 不处理</li></ol><p>我们也可以自己实现<code>RejectedExecutionHandler</code>接口，主要做一些记录日志操作。</p><h3 id="3-4-自带线程池"><a href="#3-4-自带线程池" class="headerlink" title="3.4 自带线程池"></a>3.4 自带线程池</h3><p>其实有了上面的这些基础，在看看Java默认提供的几种线程池，就很容易理解了，也就是利用这些参数的使用来封窗了一些比较常用的线程池。</p><h4 id="3-4-1-newFixedThreadPool"><a href="#3-4-1-newFixedThreadPool" class="headerlink" title="3.4.1 newFixedThreadPool"></a>3.4.1 newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定长线程池，特点是核心线程数和最大线程数相等，采用链式阻塞队列，大小为Integer.<strong>MAX_VALUE</strong><br>基本为无界队列，所以驳回策略基本失效，最大线程池理论也失效！</p><h4 id="3-4-2-newSingleThreadExecutor"><a href="#3-4-2-newSingleThreadExecutor" class="headerlink" title="3.4.2 newSingleThreadExecutor"></a>3.4.2 newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单线程池，特点是核心线程数和最大线程数都为1，采用链式阻塞队列和上面一样。所以驳回策略也失效，但是同时只能进行一个线程在运行中，所以叫单线程池。</p><h4 id="3-4-3newCachedThreadPool"><a href="#3-4-3newCachedThreadPool" class="headerlink" title="3.4.3newCachedThreadPool"></a>3.4.3newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存线程池，核心线程数为0，最大线程数最大值。由于核心线程数为0以及采用了SynchronousQueue这种不存储元素的队列，所以实际上线程会一直无限量的在运行，吞吐量会比较大，但是高峰期会对性能有影响。但是由于核心线程数为0，所以线程池也会定时清理无用线程！该线程池是需要谨慎使用的一种。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程和线程池&quot;&gt;&lt;a href=&quot;#线程和线程池&quot; class=&quot;headerlink&quot; title=&quot;线程和线程池&quot;&gt;&lt;/a&gt;线程和线程池&lt;/h1&gt;&lt;h2 id=&quot;1-何为线程&quot;&gt;&lt;a href=&quot;#1-何为线程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>锁、AQS</title>
    <link href="http://yoursite.com/2019/04/18/javabase/%E9%94%81%E3%80%81AQS/"/>
    <id>http://yoursite.com/2019/04/18/javabase/%E9%94%81%E3%80%81AQS/</id>
    <published>2019-04-18T01:58:51.000Z</published>
    <updated>2019-12-31T11:50:48.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁、AQS"><a href="#锁、AQS" class="headerlink" title="锁、AQS"></a>锁、AQS</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>在实际开发中在多线程中保证其安全性，其实我们用的最多的是互斥锁，也就是synchronized关键字，我们更多的是考虑怎么降低锁的颗粒性，以及锁持有的时间。其次就是ReentrantLock，该类和synchronized功能几乎一样，唯一的特点是它比synchronized更加灵活。</p><h2 id="2-ReentrantLock"><a href="#2-ReentrantLock" class="headerlink" title="2. ReentrantLock"></a>2. ReentrantLock</h2><h3 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h3><p>直接来看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*构造函数中可以看出，可以选择创建公平锁和非公平锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-非公平锁的加锁"><a href="#2-2-非公平锁的加锁" class="headerlink" title="2.2 非公平锁的加锁"></a>2.2 非公平锁的加锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; <span class="comment">// 加锁</span></span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// CAS判断如果是0则更新成1,这里变量state是AbstractQueuedSynchronizer抽象类中的变量</span></span><br><span class="line">        <span class="comment">// 这里我们需要知道state表示该锁一共有加锁的次数，0表示锁处于空闲状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 更新成功，保存持有锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取state</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// state=0，表示锁处理空闲状态时，直接持有锁即可</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; </span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁已被人持有，判断锁持有人是否为当前线程</span></span><br><span class="line">        <span class="comment">// 是则state+1，否表示加锁失败</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁（子类实现）获取锁失败则将线程加入等待队列中</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">// 加入等待队列</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 等待队列为空，创建一个头部队列</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 等待队列不为空，将当前node加入到队列的尾部</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非公平的加锁的已经完成，其中有一系列的CAS操作，我们要知道CAS操作是无锁的，处于线程安全的。基本所有更新的操作都是安全的！  其中还有一个点，比如在<strong>nonfairTryAcquire</strong>和<strong>addWaiter</strong>中，明明已经有了整个处理的逻辑为什么还要在外层加一层判断，这里主要是为了性能考虑。当某个状态可直接快速的决定逻辑的走向，所有可以优先判断快速处理。不必走整个完整的逻辑。当然这里牺牲了一些代码的可读性！</p><p>这一步结合简单的图来在整体了解一下加锁过程  </p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/440120/1568103962659-d4062062-d923-4db7-9105-965030e7165f.png#align=left&display=inline&height=682&name=&originHeight=682&originWidth=673&size=0&status=done&width=673#align=left&display=inline&height=682&originHeight=682&originWidth=673&status=done&width=673" alt="image"></p><p>剖析出来整体是比较清晰的。</p><h3 id="2-3-AQS中的等待队列"><a href="#2-3-AQS中的等待队列" class="headerlink" title="2.3 AQS中的等待队列"></a>2.3 AQS中的等待队列</h3><p>这里的加入等待队列，比较重点。<br>在AQS里面。维护了一个等待队列，来保存等待的线程。从上面代码可出实际头部节点在初始化的时候是没有保存线程的。实际的线程是在第二个队列中。接下来看一下acquireQueued方法做了什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳出等待队列</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取前驱节点</span></span><br><span class="line">                <span class="comment">// 如果前驱节点=头部节点，</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是否要阻塞当前线程</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                  在AQS的等待队列中，只有前置是SIGNAL状态才能开始等待。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">// 阻塞当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单的看出，首先是一个死循环，一是如果前驱节点是头部节点，再次尝试获取锁。成功则自己设为头部节点。（<strong>特点注意这里在已经在加入等待队列时，已经获取到锁了</strong>）。如果不是，则尝试加入队列同时阻塞自己。<br>看下<strong>shouldParkAfterFailedAcquire</strong>方法，检查是否允许进入阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这个状态标识，可以正常挂靠在这里</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 这个状态，会一直往前找，找到一个不属于CANCELLED的node</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 其他节点会默认为 SIGNAL</span></span><br><span class="line"><span class="comment">        * 我们这里会先走这个流程，在走第一条分支。标识可以正常挂靠</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这里队列其实是可以通过状态来标识自己是否有需要被唤醒。我们这个AQS的实现。暂时没有用到这个，一直是SIGNAL状态。<br />注意这里的死循环，简单说就是一个线程在尝试加入队列的同时，也在不断的尝试获取锁。比如发现前置节点是SIGNAL则开始阻塞线程。等待执行线程的唤醒。然后又继续重复尝试获取线程，尝试加入队列。</p><h3 id="2-4-非公平锁的解锁"><a href="#2-4-非公平锁的解锁" class="headerlink" title="2.4 非公平锁的解锁"></a>2.4 非公平锁的解锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 获取state-1</span></span><br><span class="line">        <span class="comment">// 当前线程不是持有锁的线程，直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">// state-1 = 0 表示解锁成功</span></span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c); <span class="comment">// state-1 != 0 表示是可重入锁，减了一层，</span></span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">// 判断队列是否为null</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解锁过程比较简单。主要是从队列的尾部像前找，找到对接近队列头部的节点切状态正确的节点，将其唤醒。</p><h3 id="2-5-整体流程"><a href="#2-5-整体流程" class="headerlink" title="2.5 整体流程"></a>2.5 整体流程</h3><p>看下来其实可能比较模糊，我们最后看一下流程图！</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/440120/1568173227974-3e544e96-e8a9-4940-95cb-cd5deaa5d460.png#align=left&display=inline&height=878&originHeight=878&originWidth=698&size=0&status=done&width=698#align=left&display=inline&height=878&originHeight=878&originWidth=698&status=done&width=698" alt="image"></p><p>最后文字在讲述一下基本的逻辑</p><ol><li>线程A lock，state=0，将state=1，获取到锁，此时队列为null</li><li>线程B lock，尝试获取锁失败，加入队列，由于队列为null，先初始化一个head，把自己放在head后面。</li><li>线程B 准备休眠，<strong>开始死循环</strong>，检查自己的前置节点是不是head，是则尝试获取一下锁。失败的话。开始判断自己是否可以休眠。<ul><li>检测自己的前置节点，是否为<strong>SIGNAL</strong>标识，是则直接执行休眠</li><li>前置节点为<strong>CANCELLED</strong>标识(代码是&gt;0)，将自己的node往前推，删除前置节点，直到不是<strong>CANCELLED</strong>标识</li><li>其他标识，将标识直接改成<strong>SIGNAL</strong>标识，<br>这里线程B会先进入第三条规则，因为其前置节点是空节点，没有设标识。在进去第一条规则。可以挂靠。</li></ul></li><li>线程C lock，尝试获取锁。</li><li>线程A 此时放开锁，唤醒了线程B，线程B开始尝试获取锁，注意此时线程C也在尝试获取锁，结果被线程C获取到，同时将自己设为head。而线程B又在死循环中进入休眠。等待下次唤醒。</li></ol><p>最后根据流程图看会比较简单了。<br>终于为什么叫非公平锁，其实可以看出来了！就是在获取锁的时候，首先会尝试获取一下锁。不行再加入到队列。这里就存在一些竞争关系，实际就是我上面文字描述的4、5两步骤。但是并不是完全非公平的，只在新成员加入队列前会有尝试获取锁的机会。进入队列中是按公平的策略来的。</p><h3 id="2-6-公平锁"><a href="#2-6-公平锁" class="headerlink" title="2.6 公平锁"></a>2.6 公平锁</h3><p>公平锁和非公平锁区别不大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先lock的时候，没有了提前去判断state的状态，毕竟判断了也不可能给你随便加入。<br>然后就是尝试获取锁，这里有个方法 <code>hasQueuedPredecessors</code> 这个方法主要是判断队列中是否有在等待中的线程。<br>所以这里解决了根本原因的，就是公平锁在第一次锁的时候会判断一下的队列的情况。这样就解决了上面说到的非公平锁的不公平性。</p><h3 id="2-7-Condition-用法"><a href="#2-7-Condition-用法" class="headerlink" title="2.7 Condition 用法"></a>2.7 Condition 用法</h3><h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3. Semaphore"></a>3. Semaphore</h2><p>semaphore信号量，可以控制并发访问的线程个数。<br>可以在需要访问限制中使用，比如一些连接池、限流的场景。当然很多高并发的限流工具，我们会优先采用现成的，自己写的不多。所以用的频率不高。但是自己写写测试代码倒是用的挺多。<br>来看下基本用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化，同时允许的并发个数</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取一个许可</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            semaphore.tryAcquire(); <span class="comment">//尝试获取一个许可</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放一个许可</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单看下源码,也是通过继承AQS模板来实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，维护AQS的state变量，</span></span><br><span class="line">    <span class="comment">// 也分公平和非公平模式和ReentrantLock类似的实现，这里只贴非公平锁的代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取许可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以非公平方式，尝试获取凭证</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState(); <span class="comment">// 获取state</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires; </span><br><span class="line">                <span class="comment">// 如果 remaining &gt;= 0 表示凭证够，后面的CAS是保证数据的正确性</span></span><br><span class="line">                <span class="comment">// &lt; 0 凭证不够，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123; <span class="comment">// 获取许可</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// 尝试获取，调用实现类 nonfairTryAcquireShared</span></span><br><span class="line">        <span class="comment">// 这里的不公平地方也在这里。来了什么都不管先尝试一下。</span></span><br><span class="line">        <span class="comment">// 所以这个实现在公平锁肯定会加入判断队列的情况而非公平锁就不会去判断队列的情况</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) </span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始阻塞线程 也和ReentrantLock类似</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED); <span class="comment">// 将自己加入队列</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// 死循环</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor(); <span class="comment">// 获取前置节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg); <span class="comment">// 尝试获取凭证</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功，将自己设为头部节点</span></span><br><span class="line">                        setHeadAndPropagate(node, r); </span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 开始检查自己是否可以加入队列，</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看一下和ReentrantLock其实比较类似。利用好AQS的模板效果。重点在于state的维护和队列的使用。这些都是AQS内部已经建好的。需要是掌握时机即可。</p><h2 id="4-CountDownLatch-CyclicBarrier"><a href="#4-CountDownLatch-CyclicBarrier" class="headerlink" title="4. CountDownLatch   CyclicBarrier"></a>4. CountDownLatch   CyclicBarrier</h2><p>两者都可以保证线程的优先级，也就是在多线程中能够保证线程的执行顺序，比如在拆分计算的时候，可以保证某些计算先做，某个后做。</p><h3 id="4-1-CountDownLatch"><a href="#4-1-CountDownLatch" class="headerlink" title="4.1 CountDownLatch"></a>4.1 CountDownLatch</h3><p>主要体现在一个线程等待多个线程的效果<br>比如下面的例子，导游等待多个同学，只有当同学全部到了以后就可以触发了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化，同时允许的并发个数</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"A同学在路上"</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"B同学在路上"</span>);</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            log.info(<span class="string">"2个同学到了，开车旅游"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-CyclicBarrier"><a href="#4-2-CyclicBarrier" class="headerlink" title="4.2 CyclicBarrier"></a>4.2 CyclicBarrier</h3><p>表达的是多个线程互相等待，然后一起进行的操作！<br>比如下面的旅游，但是没有老师了，自发约定地点。我这里的例子可能不是很合理。但是区别还是很明显的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">    service.execute(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"A同学到了约定地点"</span>);</span><br><span class="line">        cyclicBarrier.await(); <span class="comment">// 等待</span></span><br><span class="line">        log.info(<span class="string">"可以走了"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    service.execute(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"B同学到了约定地点"</span>);</span><br><span class="line">        cyclicBarrier.await(); <span class="comment">// 等待</span></span><br><span class="line">        log.info(<span class="string">"可以一起走了"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-区别"><a href="#4-3-区别" class="headerlink" title="4.3 区别"></a>4.3 区别</h3><p>CyclicBarrier的计数器是可以重置的，CountDownLatch  不可以。<br>CyclicBarrier是表示多个线程互相等待，然后互相一起走。CountDownLatch 表达的是一个线程等待多个线程，然后这一个线程就可以走了。<br>CyclicBarrier的API方法比较CountDownLatch 更加丰富一些，可以自己查看一下！</p><h2 id="5-FutureTask"><a href="#5-FutureTask" class="headerlink" title="5. FutureTask"></a>5. FutureTask</h2><p>futureTask也可以实现线程的等待。这里简单的看一下代码的使用！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        Future&lt;String&gt; submit1 = service.submit(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"助手1:切肉！"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"切好的肉"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Future&lt;String&gt; submit2 = service.submit(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"助手2切青椒"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"切好的青椒"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        log.info(<span class="string">"主厨准备其他东西"</span>);</span><br><span class="line">        String s = submit1.get();</span><br><span class="line">        String s1 = submit2.get();</span><br><span class="line">        log.info(<span class="string">"青椒肉丝出锅"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>比如青椒和肉丝其实也可以有两个人一起切。最后主厨就在准备好调料后，就在等待主材料。这三种都是可以同步执行的，如果主厨比较快。那么就会通过get方法，获取需要东西，然后开启等待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;锁、AQS&quot;&gt;&lt;a href=&quot;#锁、AQS&quot; class=&quot;headerlink&quot; title=&quot;锁、AQS&quot;&gt;&lt;/a&gt;锁、AQS&lt;/h1&gt;&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://yoursite.com/2019/04/14/javabase/%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2019/04/14/javabase/%E9%9B%86%E5%90%88/</id>
    <published>2019-04-14T01:58:51.000Z</published>
    <updated>2019-12-31T11:50:48.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>java中的集合主要指的Collection和Map两个接口大类<br>主要区别在于Collection是单列集合，Map是键值对的集合<br>相对于数组而言除了更加强大API使用，还有对通过对数据结构的灵活使用可以更加贴合实际的生产使用</p><h2 id="2-Collection"><a href="#2-Collection" class="headerlink" title="2. Collection"></a>2. Collection</h2><p>collection接口主要包括两大类<strong>List</strong>和<strong>Set</strong><br>区别在于List中的元素是可重复，Set中的元素是不可重复的</p><h2 id="2-1-List"><a href="#2-1-List" class="headerlink" title="2.1 List"></a>2.1 List</h2><p><strong>List</strong> 主要有ArrayList，LinkedList，两者之间的主要区别在于数据结构的不同导致的性能的差异性。</p><h3 id="2-1-1-ArrayList"><a href="#2-1-1-ArrayList" class="headerlink" title="2.1.1 ArrayList"></a>2.1.1 ArrayList</h3><p>ArrayList基于数组来实现</p><p>特点：</p><ol><li>查询快，能够根据下标快速定位数据</li><li>插入数据慢，设计到数据的移位等问题。</li></ol><h3 id="2-1-2-LinkedList"><a href="#2-1-2-LinkedList" class="headerlink" title="2.1.2 LinkedList"></a>2.1.2 LinkedList</h3><p>LinkedList基于链表来实现</p><p>特点：</p><ol><li>查询慢，因为不知道数据的具体存放地址</li><li>插入数据块，因为设计到更少的数据迁移</li></ol><p>这两个集合特点和区别也非常鲜明，主要是数组和链式来决定的。  </p><p><strong>数组</strong>实际是一个整齐排放的数据结构，所以当你知道数据的下标，便能直接获取数据。如果不知道下标，其实查询效率和链表也没什么区别了。而当你插入数据的时候，除非插入到坐标尾部，否则都会涉及到数据的迁移以保证其规则性（如果数组满了，申请扩容也会迁移）</p><p><strong>链表</strong> 相对于数组也比较清晰了。实际每个数据体都存放了上个节点和下个节点的地址，所以查询会慢，而对数据的插入基本不会涉及数据的迁移，所以插入效率会比较高</p><h2 id="2-2-Set"><a href="#2-2-Set" class="headerlink" title="2.2 Set"></a>2.2 Set</h2><p><strong>Set</strong> 主要使用的HashSet,LinkedHashSet，TreeSet</p><h3 id="2-2-1-HashSet，LinkedHashSet"><a href="#2-2-1-HashSet，LinkedHashSet" class="headerlink" title="2.2.1 HashSet，LinkedHashSet"></a>2.2.1 HashSet，LinkedHashSet</h3><p>其中<strong>HashSet</strong>，<strong>LinkHashSet</strong>在了解<strong>HashMap</strong>后会比较好理解，因为他的底层也是实际利用<strong>HashMap</strong>和<strong>LinkHashMap</strong>来实现的</p><p><strong>HashSet</strong>利用<strong>HashMap</strong>的key的唯一性来实现HashSet</p><p><strong>LinkedHashSet</strong>利用<strong>LinkedHashMap</strong>的key值唯一性，以及其顺序性来实现</p><h3 id="2-2-2-TreeSet"><a href="#2-2-2-TreeSet" class="headerlink" title="2.2.2 TreeSet"></a>2.2.2 TreeSet</h3><p>TreeSet底层采用二叉树实现，效率高，元素有序且唯一。如果排序需求可以考虑使用。</p><h2 id="3-1-Map"><a href="#3-1-Map" class="headerlink" title="3.1 Map"></a>3.1 Map</h2><p>map在实际使用中最典型的可能就是<strong>HashMap</strong>，也是必须要掌握的，具体可查询另外一篇详细文档！</p><h3 id="3-1-1-LinkedHashMap"><a href="#3-1-1-LinkedHashMap" class="headerlink" title="3.1.1 LinkedHashMap"></a>3.1.1 LinkedHashMap</h3><p>LinkedHashMap继承了HashMap，和它的区别在于HashMap的存放规则是随机的。而LinkedHashMap在其基础上了做了一个链表的结构。实际就是HashMap.Node&lt;K,V&gt; 有加了一个before和after属性。</p><p><strong>LinkedHashMap</strong>的使用时，有两种排序规则，一种是按插入排序和访问排序</p><ul><li>插入排序： 调用put时来排序，也是默认的</li><li>访问排序： 每次get会改变其排序，get的数据会自动到尾部</li></ul><h2 id="3-4-Collections"><a href="#3-4-Collections" class="headerlink" title="3.4 Collections"></a>3.4 Collections</h2><p>Collections.unmodifiableXXX:collection、List、Set、Map<br>通过Java自带的工具类来创建一个只读的集合。底层主要是对get操作直接抛出异常来保证其只读行。</p><p>Guava.ImmutableXXX:Collection、List、Set、Map<br>有可以通过GuavaCache下的Immu..包来保证只读性。实现都差不多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h1&gt;&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringMVC的一次调用</title>
    <link href="http://yoursite.com/2019/04/12/framework/SpringMVC%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/12/framework/SpringMVC%E7%9A%84%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8/</id>
    <published>2019-04-12T01:58:51.000Z</published>
    <updated>2019-12-31T11:54:13.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC的一次调用"><a href="#SpringMVC的一次调用" class="headerlink" title="SpringMVC的一次调用"></a>SpringMVC的一次调用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SpringMVC其实我觉得可讲的还不是很多，但是曾经面试最喜欢的问的就是SpringMVC的一次调用过程，不知道现在是什么情况。</p><h2 id="SpringMVC的作用"><a href="#SpringMVC的作用" class="headerlink" title="SpringMVC的作用"></a>SpringMVC的作用</h2><p>首先我们要知道SpringMVC是以Servlet为基础的一个框架，属于web层的MVC框架，用来替代Servlet来做http请求的响应和处理。通过它我们可以通过几个简单的注解就可以高效的处理请求和返回数据。</p><p>前面容器已经讲过Servlet，在看SpringMVC就比较简单了。我们知道Servlet主要用来对请求的初始化，处理已经返回数据。假如我们没有Servlet那么我们对每个请求都要不厌其烦的去配置对每个请求的拦截，然后对每个请求做自己业务处理。SpringMVC就将其做了简化动作以便我们高效开发。</p><h2 id="SpringMVC的调用过程"><a href="#SpringMVC的调用过程" class="headerlink" title="SpringMVC的调用过程"></a>SpringMVC的调用过程</h2><p>直接抛出一个网上随处可找的图，然后直接说明结果，最后简单讲解一下其大致思路</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/spring/Spring-SpringMVC-guoc.png" alt="SpringMVC的一次调用"></p><p>上图算是找到的一张比较完整的图。实际我也不会记得这么详细，大致的过程为</p><ol><li>客户端发起请求，进入DispatcherServlet</li><li>DispatcherServlet通过传入的url找到对应的Handle(即Controller)</li><li>最后调用其逻辑</li><li>获取到返回值后，经过视图解析器，返回Html（如果是ajax就直接返回数据）</li></ol><p>这里的逻辑我写的比较简单，不想弄得太复杂</p><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>DispatcherServlet是SpringMVC的核心功能，本质是一个Servlet。这个Servlet逻辑处理比较多。但是也好理解。直接看代码了。不做配置说明了</p><p>看代码之前先要了解一下其的类的关系图</p><p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/spring/SpringMVC-dispatcherServlet-gram312fs.png" alt="dispatcherServlet-class"></p><p>可以明显的看到他还是集成了Servlet,而且是HttpServlet只不过他又加了几层封装（每次看Spring的代码，其实都可以猜到了，它的风格就这样）,那么如果肯定去找doService方法咯</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//---忽略代码--</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ---忽略代码---</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 对文件的处理</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line">            <span class="comment">// 获取handler，通过RequestMappingHandlerMaping获取</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取Handler适配器</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对浏览器请求的特殊处理</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 实际调用Handle的方法，返回封装个后的ModelAndView</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳转到指定页面（跳转到指定的视图）</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本源码也就这里了。</p><blockquote><p>这里讲的不很仔细，后面再补充!</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringMVC的一次调用&quot;&gt;&lt;a href=&quot;#SpringMVC的一次调用&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC的一次调用&quot;&gt;&lt;/a&gt;SpringMVC的一次调用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://yoursite.com/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringMVC,Spring" scheme="http://yoursite.com/tags/SpringMVC-Spring/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://yoursite.com/2019/04/12/javabase/%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/04/12/javabase/%E5%8F%8D%E5%B0%84/</id>
    <published>2019-04-12T01:58:51.000Z</published>
    <updated>2019-12-31T11:50:48.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java的反射机制是指在运行时获取类的属性和方法。并且能够动态修改属性和调用方法。</p><p>在日常开发中尤其是在集成代码，简化代码的时候，我们经常会遇到不能在编译时就能获取属性。这时候我们会用反射来解决这个问题。</p><p>首先要明确的是：通过来反射获取属性和调用方法，肯定比直接用代码硬编码要慢。所以反射我们需要谨慎的使用，尤其是当自己编写的方法可能会频繁调用的时候。就需要考虑加入缓存或者考虑是否不使用反射来达到效果。</p><p>对于反射为什么会慢，其实我自己也没有深刻理解。这篇<a href="https://stackoverflow.com/questions/1392351/java-reflection-why-is-it-so-slow" target="_blank" rel="noopener">stackoverflow</a>有些讨论。</p><p>大致可以看到是:</p><ol><li>反射相对直接调用，JVM并不是很好的去对其优化。</li><li>必须发现正在调用/创建的所有内容</li><li>参数需要重新包装成数组，同时还要捕获异常<code>InvocationTargetException</code></li><li>反射并不慢，相对网络传输、解析xml等其他耗时行为。</li></ol><h2 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h2><p>java中反射的api相对比较简单。这里简单写一下常用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;ReflectBean&gt; clzss = ReflectBean<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 1. 创建实例</span></span><br><span class="line">        ReflectBean reflectBean = clzss.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 字段操作</span></span><br><span class="line">        <span class="comment">// 获取字段 (只能获取public的,但是可以获取从父类继承过来的public属性)</span></span><br><span class="line">        Field name = clzss.getField(<span class="string">"pubName"</span>);</span><br><span class="line">        Field[] fields = clzss.getFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字段 (获取当前类的所有字段，但是获取不到父类继承来的属性)</span></span><br><span class="line">        Field name1 = clzss.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        Field[] declaredFields = clzss.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字段属性</span></span><br><span class="line">        <span class="comment">// 在获取private属性时，必须将该属性设为true才能直接get。你可以选择通过get，set方法来获取</span></span><br><span class="line">        name1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name1.set(reflectBean,<span class="string">"反射设置的name"</span>);</span><br><span class="line">        String str = (String)name1.get(reflectBean);</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 方法操作</span></span><br><span class="line">        <span class="comment">// 获取方法 这里和field一样操作。不多赘述</span></span><br><span class="line">        Method method = clzss.getMethod(<span class="string">"method"</span>);</span><br><span class="line">        Method[] methods = clzss.getMethods();</span><br><span class="line">        Method priMethod = clzss.getDeclaredMethod(<span class="string">"priMethod"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Method[] declaredMethods = clzss.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法</span></span><br><span class="line">        Object invoke = method.invoke(reflectBean);</span><br><span class="line"></span><br><span class="line">        priMethod.setAccessible(<span class="keyword">true</span>); <span class="comment">// 下面是私有的方法，也要加上这句</span></span><br><span class="line">        Object string = priMethod.invoke(reflectBean, <span class="string">"string"</span>);</span><br><span class="line">        System.out.println(invoke);</span><br><span class="line">        System.out.println(string);</span><br><span class="line"></span><br><span class="line">        System.out.println(reflectBean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是如此了。反射暂时没有发掘有撒可扩充的。有实际的比较好的实际使用再来更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;jav
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>并发基础</title>
    <link href="http://yoursite.com/2019/04/11/javabase/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/11/javabase/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</id>
    <published>2019-04-11T01:58:51.000Z</published>
    <updated>2019-12-31T11:47:36.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><h2 id="并发BUG的源头"><a href="#并发BUG的源头" class="headerlink" title="并发BUG的源头"></a>并发BUG的源头</h2><p>并发的原因现在主流是三种，原子性、可见性、有序性。本质乃是计算机CPU、内存之间的问题。问题本身很复杂，才疏学浅只简单的讲下理解的。目的就是为了有个基本的概率，可以更好的理解并发。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>一个线程对共享变量的修改，其他线程是否能够立即看到，就称为<strong>可见性</strong>。至于为什么会有这个问题，其实主要是<strong>因为缓存的问题导致的</strong>。<br>在计算机中CPU并不是直接操作内存里面的数据，每个CPU本身也会缓存，CPU只会操作自己缓存的数据，然后CPU缓存和内存进行交互。多线程的情况就会出现缓存和主内存的数据不一致的问题！  </p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/440120/1567653661567-5c22de1d-3405-4780-9dbc-ae1d43deb302.png#align=left&display=inline&height=347&originHeight=347&originWidth=447&size=0&status=done&width=447" alt="image"></p><p>CPU缓存和内存的关系图<br>其实在Java的内存模型中，也会出现这种情况，在下图中可以明显看到。JAVA的引用对象，每个线程在修改对象数据时，并不是直接修改内存的数据，而是每个线程都保存了一份实际内存的数据备份。这样也会可见性的问题</p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/440120/1567653693113-ab3ba16c-52e9-4dbf-aeef-4347223f575b.png#align=left&display=inline&height=603&name=&originHeight=603&originWidth=723&size=0&status=done&width=723" alt="image"></p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性的日常理解是：某个单位已经到了最小不可拆分的单位。就说明这个单位具有原子性。在编程中其实也比较好理解，比如 <code>count += 1</code> 就不具备原子性。因为我们都知道他是分为几步完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将count的数据从内存中取出  --&gt;  <span class="number">1</span></span><br><span class="line">count+<span class="number">1</span>  --&gt;  <span class="number">2</span></span><br><span class="line">将count放回内存中 --&gt;  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>这三部在执行过程中。都会出现中断或者多线程的原因其他线程中途也对count进行了操作。这一步操作并不是最小单位。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性，就是程序按代码编写的逻辑执行。但是实际情况下程序并不是按代码编写的逻辑执行的，为什么会这样？主要原因是编译优化，比如程序中： <code>int a=1; int b = 2;</code> 正常应该先做a，在做b。但是实际情况并不是确定，有可能b先做，但是在<strong>编译优化并不会影响程序在单线程中执行</strong>，多线程就不确定了。</p><blockquote><p>在单例模式中的双重检查有一个很经典的例子。</p></blockquote><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>理解以上三种特性后，想要避免多线程的BUG，比如可见性是缓存导致的，我们就禁用缓存。有序性是编译优化导致的，我们就禁用编译优化。这样做确实可以减少很多并发的BUG，但是会导致性能大减。</p><p>合理方案应该是<strong>按需优化</strong>。</p><p>现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。</p><h3 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h3><p>Happens-Before 原则主要是Java推出的一些规范。</p><ol><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li><li>管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。</li><li>volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后顺序。</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li><li>线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li><li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。</li></ol><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatile 关键可以对象的可见性以及指令重排序，以为volatile修饰的变量在操作时会通过内存屏障来禁止指令重排序。而且其修饰的关键字在使用变量和更新变量时都会更新内存中的变量缓存和提交线程中的变量缓存。所以解决了可见性的问题，但是无法解决原子性的问题</p><blockquote><p>主要使用用于标记状态、doubleCheck</p></blockquote><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>final关键字申明的对象是无法再修改的，也就天然的保证了其可见性的问题，只有查看而没有修改。（注意final修饰引用对象时，对象内部的引用对象也是可以修改的）。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁主要是解决其原子性的问题。后续会详细讲解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;并发基础&quot;&gt;&lt;a href=&quot;#并发基础&quot; class=&quot;headerlink&quot; title=&quot;并发基础&quot;&gt;&lt;/a&gt;并发基础&lt;/h1&gt;&lt;h2 id=&quot;并发BUG的源头&quot;&gt;&lt;a href=&quot;#并发BUG的源头&quot; class=&quot;headerlink&quot; title=&quot;并
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JVM之GC</title>
    <link href="http://yoursite.com/2019/03/15/jvm/JVM%E4%B9%8BGC/"/>
    <id>http://yoursite.com/2019/03/15/jvm/JVM%E4%B9%8BGC/</id>
    <published>2019-03-15T01:58:51.000Z</published>
    <updated>2019-12-31T11:51:52.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之GC"><a href="#JVM之GC" class="headerlink" title="JVM之GC"></a>JVM之GC</h1><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>讲垃圾回收算法之前，先简单说一下两个算法依据</p><ol><li>引用计数算法：</li></ol><p>java在运行时，一个对象如果有被引用则对象实例+1，引用失效-1，垃圾回收时，找到引用为0的回收即可，这种算法缺点比较明显，当对象互相引用时，则无法回收到。JVM没有采用该算法<br>2. 可达性分析算法<br>相对于引用计数算法，有根节点的概念，通过根节点的对象引用链，来找到不需要回收的对象。最终无法到达的对象即为需要回收的对象。跟节点如何选取：类加载器、Thread、虚拟机栈本地变量、static成员、常量引用、本地方法栈等等都是root节点的选择对象</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>将需要回收的对象进行标记，最后进行清除</p><p>特点：效率一般且会产生碎片</p><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>和标记清除类似，先标记需要回收的对象，不同之处在于清除对象后，会将现有的对象进行整理来解决碎片化的问题。但是比较耗时</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法会将内存按容量分为两块区域，每次只使用其中一块。回收垃圾时，将保留的对象直接复制到另外一块区域，同时直接清除本区域的对象。</p><p>特点：简单高效、空间利用率低</p><h3 id="分带垃圾回收"><a href="#分带垃圾回收" class="headerlink" title="分带垃圾回收"></a>分带垃圾回收</h3><p>分带垃圾回收是将内存分类，Young区和old区，每个分区使用不同的回收算法。来高效的利用回收算法的优缺点。JVM中也是使用了改逻辑来处理的。<br>Young区：复制算法<br>Old区：标记清除或标记整理</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="串行收集器Serial"><a href="#串行收集器Serial" class="headerlink" title="串行收集器Serial"></a>串行收集器Serial</h3><p>开启参数：-XX:+UseSerialGC</p><p>串行收集器属于一种传统的收集器。内存很小时会使用，比如一些嵌入式的程序中会使用该收集器。</p><p>特点是：简单高效，效率高。但是必须暂停其他所有的工作线程</p><h3 id="并行收集器Parallel"><a href="#并行收集器Parallel" class="headerlink" title="并行收集器Parallel"></a>并行收集器Parallel</h3><p>开启参数：-XX:+UseParallelGC,-XX:+UseParallelOldGC<br>service模式默认的收集器</p><h3 id="并发收集器Concurrent"><a href="#并发收集器Concurrent" class="headerlink" title="并发收集器Concurrent"></a>并发收集器Concurrent</h3><p>CMS：-XX:+UseConcMarkSweepGC  -XX:+UseParNewGC</p><p>G1：-XX:+UseG1GC</p><h2 id="JVM常用的收集器和优化点"><a href="#JVM常用的收集器和优化点" class="headerlink" title="JVM常用的收集器和优化点"></a>JVM常用的收集器和优化点</h2><p>以JDK8为例，可以查看官网：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/" target="_blank" rel="noopener">HotSpot虚拟机垃圾收集优化指南</a></p><h3 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h3><p>并行收集器(也称为吞吐量收集器)是相对于串行收集器而言的，区别在于收集垃圾时，使用的多线程来收集。收集时也是需要暂停应用程序的。</p><p>设置线程数 <code>-XX:ParallelGCThreads=&lt;N&gt;</code><br>核心数N小于8时等于N，大于8时为5/8。 也可以用上诉方式调优</p><p>在并行收集器中使用了一种自动调整的方法，JDK推荐使用以下3个参数来帮助收集器来调整性能。 以下排名有先后顺序</p><ul><li>最大垃圾回收暂停时间  <code>-XX:MaxGCPauseMillis=&lt;N&gt;</code></li><li>吞吐量 <code>-XX:GCTimeRatio=&lt;N&gt;</code>  比如配置99，则表示收集时间 1/1+N 为1%</li><li>内存占用 -Xmx</li></ul><p>通过这三个参数，收集器会自动优化程序，达到以上的要求。</p><h4 id="Generation-Size-Adjustment"><a href="#Generation-Size-Adjustment" class="headerlink" title="Generation Size Adjustment"></a>Generation Size Adjustment</h4><p>同时我们还可以调整分区的动态适应参数来帮助其更好的优化</p><ul><li><code>-XX:YoungGenerationSizeIncrement=&lt;Y&gt;</code> young generation增长比率 默认为20</li><li><code>-XX:TenuredGenerationSizeIncrement=&lt;T&gt;</code> tenured generation增长比率 默认为20</li><li><code>-XX:AdaptiveSizeDecrementScaleFactor=&lt;D&gt;</code> 缩小因子，如果增长比率是X，那么缩小比率就是 X / D, 默认为4，也就是5%</li></ul><p>如果collector决定在启动的时候就增长generation，那么会在原增长比率上有一个增加量，这个增加量会随着gc次数越来越低，这个主要是为了提高启动的性能。缩小时没有增加量。</p><p>如果最大pause time的目标没有达成，那么会一次自会缩小一个generation。如果两个generation都达不到目标，那么pause time较长的那个会先被缩小</p><p>如果throughput的目标没有达到，那么两个generation区域都会被增加。然后按照比例扩展，比如young generation的gc时间占到总gc时间的25%，而增长比率是20%，那么实际会增长5%。</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS适合在响应时间要求比较的服务器上使用，</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM之GC&quot;&gt;&lt;a href=&quot;#JVM之GC&quot; class=&quot;headerlink&quot; title=&quot;JVM之GC&quot;&gt;&lt;/a&gt;JVM之GC&lt;/h1&gt;&lt;h2 id=&quot;垃圾回收算法&quot;&gt;&lt;a href=&quot;#垃圾回收算法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM之内存模型</title>
    <link href="http://yoursite.com/2019/03/14/jvm/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/14/jvm/JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-03-14T01:58:51.000Z</published>
    <updated>2019-12-31T11:51:52.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM之内存模型"><a href="#JVM之内存模型" class="headerlink" title="JVM之内存模型"></a>JVM之内存模型</h1><h2 id="JVM-内存模型以及分区"><a href="#JVM-内存模型以及分区" class="headerlink" title="JVM 内存模型以及分区"></a>JVM 内存模型以及分区</h2><h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>栈分为<strong>java虚拟机栈</strong>和<strong>本地方法栈</strong></p><p>java虚拟机栈是线程私有，生命周期和线程相同。</p><p>每个方法都会创建一个栈帧，用于存放局部变量表，操作栈，动态链接，方法出口等。每个方法被调用，直到执行完毕，对于着一个栈帧的入栈到出栈的过程。</p><h3 id="方法区-（也可以叫永久代）"><a href="#方法区-（也可以叫永久代）" class="headerlink" title="方法区 （也可以叫永久代）"></a>方法区 （也可以叫永久代）</h3><p>方法区也叫作永久代，主要存放虚拟机加载的类信息，常量和静态变量等数据。</p><p>JDK8中叫元空间(MetaSpace)，移除出JVM。直接使用在内存中</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>当前线程执行的行号指示器，在循环，分支，跳转，以及多线程之间交易都会使用这个，它是线程私有的。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>堆是所有线程共享的，唯一目的就是存放对象实例</p><p>堆区分为新生代和老年代，新生代又分为三个区域，比例为8:1:1</p><p>新生代采用的复制算法来回收对象。</p><p>老年代采用标记清除算法和标记-整理法</p><blockquote><p>堆区参数有：-Xms 堆最小值 -Xmx 堆最大值， 一般情况下，可以讲堆内存设置到物理内存的百分之八十。两者相等可以避免内存的跳动<br>新生代堆参数有：-XX:NewSize 新生代最小值，-XX:MaxNewSize 新生代最大值<br>永久代大小调整：-XX:MaxPermSize  JDK8已经取消了，转移到外部内存中<br>-XX:MaxTenuringThreshold  设置新生代对象转到老年代需要经过多少次垃圾回收</p></blockquote><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><ol><li>加载<br>获取二进制字节流，同时将静态存储结构转换为方法区数据结构</li><li>验证<br>主要验证字节流的格式规范</li><li>准备<br>此阶段主要分配变量比如static的变量，分配类变量的初始值。只有final才会被分配的正确的值</li><li>解析</li><li>初始化<br>这一步主要初始化静态代码块，构造函数，父类的初始化等</li><li>使用</li><li>卸载  由GC来处理</li></ol><h3 id="双亲委派模型：Bootstrap-ClassLoader、ExtensionClassLoader、ApplicationClassLoader。"><a href="#双亲委派模型：Bootstrap-ClassLoader、ExtensionClassLoader、ApplicationClassLoader。" class="headerlink" title="双亲委派模型：Bootstrap ClassLoader、ExtensionClassLoader、ApplicationClassLoader。"></a>双亲委派模型：Bootstrap ClassLoader、ExtensionClassLoader、ApplicationClassLoader。</h3><p>类加载器按照层次，从顶层到底层，分为以下三种：</p><p>（1）启动类加载器（BootstrapClassLoader）</p><p>这个类加载器负责将存放在JAVA_HOME/lib下的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。</p><p>（2）扩展类加载器（ExtensionClassLoader）</p><p>这个加载器负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</p><p>（3）应用程序类加载器（ApplicationClassLoader）</p><p>这个加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，可直接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM之内存模型&quot;&gt;&lt;a href=&quot;#JVM之内存模型&quot; class=&quot;headerlink&quot; title=&quot;JVM之内存模型&quot;&gt;&lt;/a&gt;JVM之内存模型&lt;/h1&gt;&lt;h2 id=&quot;JVM-内存模型以及分区&quot;&gt;&lt;a href=&quot;#JVM-内存模型以及分区&quot; cla
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM调试命令</title>
    <link href="http://yoursite.com/2019/03/12/jvm/JVM%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/03/12/jvm/JVM%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/</id>
    <published>2019-03-12T01:58:51.000Z</published>
    <updated>2019-12-31T11:51:52.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM调试命令"><a href="#JVM调试命令" class="headerlink" title="JVM调试命令"></a>JVM调试命令</h1><h2 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h2><h3 id="标准参数"><a href="#标准参数" class="headerlink" title="标准参数"></a>标准参数</h3><p>-help，-version</p><h3 id="X参数"><a href="#X参数" class="headerlink" title="X参数"></a>X参数</h3><p>-Xint  解释执行<br>第一次本地执行<br>-Xmixed  混合模式  </p><h3 id="XX参数"><a href="#XX参数" class="headerlink" title="XX参数"></a>XX参数</h3><p>-XX:+PrintFlagsInitial  查看JVM的初始化参数<br>-XX:+PrintFlagsFinal    查看JVM的运行参数</p><p>JVM参数有很多，只需要记住一些关键的即可。平时多积累知道有哪些参数就可以。忘记的话直接使用-help即可。也可以查看官网<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html" target="_blank" rel="noopener">Java命令官网说明</a></p><p>也可以使用<code>java -XX:+PrintFlagsFinal pid</code> 对常用命令进行总结</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="jps-ll"><a href="#jps-ll" class="headerlink" title="jps [-ll]"></a>jps [-ll]</h3><p>查看运行中的java进程，快速找到需要的java进程id<br>-ll   查看详细的class名</p><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>查看java的信息  </p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/440120/1572592554635-be02e3ca-0301-412f-af5b-bf466fcc1f39.png#align=left&display=inline&height=216&originHeight=216&originWidth=1154&size=0&status=done&width=1154" alt="image"></p><p>命令比较简单，主要查看某些命令的配置参数<br><code>jinfo -flags [pid]</code> 可查看一些基础命令</p><h3 id="jstat-查看JVM的统计信息"><a href="#jstat-查看JVM的统计信息" class="headerlink" title="jstat  查看JVM的统计信息"></a>jstat  查看JVM的统计信息</h3><p><code>jstat -&lt;option&gt; [-t] [-h]  [&lt;interval&gt; [&lt;count&gt;]]</code></p><ul><li>option：参数</li><li>-t：添加一个时间戳参数</li><li>-h：指定多少行输出一次表头</li><li>interval：执行每次的间隔时间，单位为毫秒</li><li>count： 用于指定输出多少次记录，缺省则会一直打印</li></ul><p>option的参数有很多</p><ul><li>-class 显示ClassLoad的相关信息；</li><li>-compiler 显示JIT编译的相关信息；</li><li>-gc 显示和gc相关的堆信息；</li><li>-gccapacity    显示各个代的容量以及使用情况；</li><li>-gcmetacapacity 显示metaspace的大小</li><li>-gcnew 显示新生代信息；</li><li>-gcnewcapacity 显示新生代大小和使用情况；</li><li>-gcold 显示老年代和永久代的信息；</li><li>-gcoldcapacity 显示老年代的大小；</li><li>-gcutil   显示垃圾收集信息；</li><li>-gccause 显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因；</li><li>-printcompilation 输出JIT编译的方法信息；</li></ul><p>重点说一下<code>-gc</code>  </p><p><img src="https://cdn.nlark.com/yuque/0/2019/png/440120/1572592554627-8a590121-18be-4a5b-8e1e-6fa3a3314d16.png#align=left&display=inline&height=216&originHeight=216&originWidth=1154&size=0&status=done&width=1154" alt="image"></p><p>执行以上命令就可以查看gc相关的堆信息，我写的每秒刷新一次。一共10次</p><ul><li>S0C、S2C、S0U、S1U：S0和S1的总量和使用量</li><li>EC、EU：Eden区的总量和使用量</li><li>OC、OU：Old区的总量和使用量</li><li>MC、MU：Metaspace区的总量和使用量</li><li>CCSC、CCSU：压缩类控件总量和使用量</li><li>YGC、YGCT：YoungGC的次数和时间</li><li>FGC、FGCT：FullGC的次数和时间</li><li>GCT：总的GC时间</li></ul><p>也可以在项目中加入XX参数，当出现gc时，自动写入日志，注意日志的文件夹必须提前创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC 输出GC日志</span><br><span class="line">-XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span><br><span class="line">-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">-Xloggc:..&#x2F;logs&#x2F;gc.log 日志文件的输出路径</span><br></pre></td></tr></table></figure><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>jmap主要用于查看JVM内存信息。主要还可以到处dump文件。利用MAT来分析内存溢出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=help.hprof 9480</span><br></pre></td></tr></table></figure><p>也可以在项目中加入XX参数。在项目出现内存溢出时，自动导出dump。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HelpDumpOnOutOfMemoryError</span><br><span class="line">-XX:HelpDumpPath&#x3D;.&#x2F;</span><br></pre></td></tr></table></figure><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>jstack 主要是用于打印线程，检查死锁和死循环<br>jstack [pid] 如果程序中存在死锁和死循环。最后一行一般是可以看到的。</p><p>实际中可以使用 jstack [pid] &gt; aaa.txt 将其输出到文件中再仔细研究问题。也可以的</p><ul><li>NEW    线程还没有启动</li><li>RUNNALE  准备启动</li><li>BLACKED  等待锁中获取，以执行</li><li>WAITING  等待中</li><li>TIMED WAITING 等待中</li><li>TERMINATED 退出</li></ul><h2 id="远程监控"><a href="#远程监控" class="headerlink" title="远程监控"></a>远程监控</h2><p>jvisualVM 监控java进程</p><p>远程监控时需要添加以下参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote</span><br><span class="line">-Dcom.sun.management.jmxremote.port&#x3D;9099</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl&#x3D;false</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate&#x3D;false</span><br><span class="line">-Djava.rmi.server.hostname&#x3D;127.0.0.1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM调试命令&quot;&gt;&lt;a href=&quot;#JVM调试命令&quot; class=&quot;headerlink&quot; title=&quot;JVM调试命令&quot;&gt;&lt;/a&gt;JVM调试命令&lt;/h1&gt;&lt;h2 id=&quot;参数类型&quot;&gt;&lt;a href=&quot;#参数类型&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="http://yoursite.com/2019/03/12/nosql/Redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/03/12/nosql/Redis%E5%9F%BA%E7%A1%80/</id>
    <published>2019-03-12T01:58:51.000Z</published>
    <updated>2019-12-31T11:54:01.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><ul><li><p>REDIS_ENCODING_INT（long类型的整数）</p></li><li><p>REDIS_ENCODING_EMBSTR embstr （编码的简单动态字符串） &lt; 44字节使用</p></li><li><p>REDIS_ENCODING_RAW （简单动态字符串）</p></li><li><p>REDIS_ENCODING_HT （字典）</p></li><li><p>REDIS_ENCODING_LINKEDLIST （双端链表）</p></li><li><p>REDIS_ENCODING_ZIPLIST （压缩列表）</p></li><li><p>REDIS_ENCODING_INTSET （整数集合）</p></li><li><p>REDIS_ENCODING_SKIPLIST （跳跃表和字典）</p></li><li><p>string：  raw int embstr</p></li><li><p>hash: hashTable zipList</p></li><li><p>list: linkedList  zipList</p></li><li><p>set： hashTable intset</p></li><li><p>zset: skiplist ziplist</p></li></ul><h2 id="各种类型的常用命令"><a href="#各种类型的常用命令" class="headerlink" title="各种类型的常用命令"></a>各种类型的常用命令</h2><p><a href="https://redis.io/commands/#" target="_blank" rel="noopener">官网指令查询</a></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>远程连接时，redis配置文件，需要将bind修改为指定的ip才能连接</p><p>redis-cli -h 138.138.138.138  -p  6379 -a password</p><h3 id="通用指令"><a href="#通用指令" class="headerlink" title="通用指令"></a>通用指令</h3><p>keys <strong>不建议生产环境使用</strong> O(n)</p><p>keys *   查出所有key<br>keys test?   查出所有test开头的5位字符，?表示一个字符<br>keys test*   查出test开头所有key</p><p>实际生产环节中可以使用。查询指定数量的key<br>SCAN 0 MATCH scxx* COUNT 200</p><p>dbsize 查询所有数据总数</p><p>exists key  判断key是否存在<br>return: 0  1</p><p>del key 删除某个key，可以一次性删除说个<br>return: 0  成功删除key的数量</p><p>expire key seconds 设置过期时间</p><p>ttl key  查询key剩余的过期时间<br>return: -1：没有过期时间   -2：key不存在</p><p>persist key  去掉过期时间</p><p>type key  判断key的类型<br>return: string,hash,list,zet,szet,none</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>get set del</p><p>incr decr 自增减1</p><p>incrby decrby  自增减自定义数字</p><p>setnx  key不存在才设置</p><p>setxx  key存在才设置</p><p>mset mget  批量操作</p><p>append  添加字符串  return: 新的字符串长度</p><p>strlen  字符串长度</p><p>getrange key start end  获取指定的字符串，下标从0开始</p><p>setrange key offset value 修改指定下标后的所有字符串</p><h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hget hset hdel</p><p>hset key filed value</p><p>hgetall  获取的所有和filed和value</p><p>hexists  判断某个filed是否存在</p><p>hlen 获取filed的数量</p><p>hmget hmset  批量操作</p><p>hsetnx 存在则新增数据</p><p>hincrby 增加自定义数字(没有自定义减)</p><h3 id="list：-有序，可以重复，左右两边弹出"><a href="#list：-有序，可以重复，左右两边弹出" class="headerlink" title="list： 有序，可以重复，左右两边弹出"></a>list： 有序，可以重复，左右两边弹出</h3><p>lpush rpush  左边插入，右边插入</p><p>key value1 value2 value3 value4</p><p>lpop rpop 左边弹出数据,右边弹出数据</p><p>linsert 在list指定的值前后插入newValue  </p><p>linsert key before|after value newValue</p><p>lrem 删除数据  </p><p>lrem key count value<br>注意count的值的特性:</p><ol><li>count &gt; 0 : 从头到尾删除count个等于value的值</li><li>count &lt; 0 ：从尾到头删除count个等于value的值</li><li>count = 0 ：删除所有等于vlaue的值</li></ol><p>ltrim 修剪数组，保留指定的部分<br>ltrim key start end  注意负数，<br>0：表示第一个数据  -1：表示倒数第一个数据  -2：表示倒数第二个数据…</p><p>lrange key start end 范围查询 闭区间</p><p>lindex key index  根据下标取数据</p><p>llen key  获取列表的长度</p><p>lset key index newValue  设置指定下标的数据</p><p>blpop brpop 阻塞版本</p><h3 id="set-集合-不可以重复"><a href="#set-集合-不可以重复" class="headerlink" title="set 集合 不可以重复"></a>set 集合 不可以重复</h3><p>sadd 添加元素，可添加多个元素</p><p>srem 删除数据,可删除多个元素</p><p>scard 获取集合的大小</p><p>sinter sdiff sunion  获取集合的交集、差集、并集</p><p>sismember 判断元素是否在集合中</p><p>srandmember 随机挑选指定数量的元素</p><p>spop 随机弹出一个元素</p><p>smembers 取出集合中的所有元素</p><h3 id="zset-有序集合-有序，score可以重复-member不可以重复"><a href="#zset-有序集合-有序，score可以重复-member不可以重复" class="headerlink" title="zset 有序集合 , 有序，score可以重复,member不可以重复"></a>zset 有序集合 , 有序，score可以重复,member不可以重复</h3><p>zadd 添加元素  </p><p>zadd key score member score elment …</p><p>zrem 删除指定的元素<br>zrem key member …</p><p>zcard 获取集合的大小</p><p>zscore key member  获取指定member的分数</p><p>zincrby key num member 增加某个member的分数</p><p>zrank key member 获取排名(从0开始)</p><p>zrevrank key member 获取指定元素的排序(从高到低排序)</p><p>zrange key strat end 获取排名内的数据</p><p>zrevrange 根据排名内的数据（从高到低）</p><p>zrangebyscore 获取指定分数之间的数据<br>zrangebyscore key minScore maxScore</p><p>zrevrangebyscore 获取制定分数之间的数据，从高到低排名</p><p>zcount 获取指定分数范围的个数<br>zcount key minScore maxScore</p><p>zremrangebyrank 根据排名来删除数据<br>zremrangebyrank key start end</p><p>zremrangebyscore 删除指定分数内的数据<br>zremrangebyscore key minScore maxScore</p><p>zinterscore zunionscore 集合操作。 获取集交集，并集</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Redis基础&quot;&gt;&lt;a href=&quot;#Redis基础&quot; class=&quot;headerlink&quot; title=&quot;Redis基础&quot;&gt;&lt;/a&gt;Redis基础&lt;/h1&gt;&lt;h2 id=&quot;基础数据结构&quot;&gt;&lt;a href=&quot;#基础数据结构&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="NoSql" scheme="http://yoursite.com/categories/NoSql/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>其他模式</title>
    <link href="http://yoursite.com/2019/02/14/javabase/shejimoshi/%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/14/javabase/shejimoshi/%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F/</id>
    <published>2019-02-14T01:58:51.000Z</published>
    <updated>2019-12-31T11:51:30.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>设计模式概括的讲很多资料写的项目的有23种设计模式，但是实际上设计模式都比较简单。有些时候有些模式一直都在用，直到详细看了那么设计模式才了解原来这也算是一个设计模式，比如模板方法模式。有些设计模式也比较简单，有些则实际用的不多。我也没撒东西拿出来当读讲。所以这片文档做一个统称。</p><p>毕竟当我们深刻了解所有的设计模式后，可以发现这已经和代码没有任何关系了。一切都是看业务看需求。看我们是不是能够深刻的抓住业务的主体。抓住其中痛点以及编码的痛点。同时当别人想对我们的代码进行扩充时也能够在不修改源代码的情况下进行自主扩充。</p><p>毕竟我们要抓住其本质：开闭原则。对扩展开放，对修改闭合。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法：通常我们在类中定义一个操作的骨干架子，将一些不确定的量交给子类去实现。子类可以通过扩展的方式来功能。</p><p>优点以及特点：</p><ol><li>封装了不可变部分，将扩展部分交给子类去实现，父类中也可以提取公共代码，提高代码的复用率</li><li>符合开闭原则</li></ol><p>缺点：</p><ol><li>扩展部分交给子类实现会导致子类增多。系统比较臃肿</li><li>在查看代码逻辑时，是一种反向控制结构，提高代码的阅读难度（Spring常有…）</li></ol><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式是将某些大量使用的都对象，由于具有相同性，所有可以对象进行提前缓存。达到共享元数据的概念（有点缓存的概率）。</p><p>比如<code>Integer.valueOf(int i)</code>中将-128~128之间的数据进行缓存，因为JVM任务这些小整数，使用频率比较高！</p><p>比如String的常量池，也可以说是享元模式</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>说到装饰模式首先想到的是IO，因为IO就是装饰者模式的一种使用。</p><p>装饰模式是在主对象的主体结构不变化的情况，对其进行扩充。使其更加好用。</p><p>比如IO中常用的：BufferedInputStream、BufferedReader都是对InputStream和Reader的装饰类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;其他模式&quot;&gt;&lt;a href=&quot;#其他模式&quot; class=&quot;headerlink&quot; title=&quot;其他模式&quot;&gt;&lt;/a&gt;其他模式&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
