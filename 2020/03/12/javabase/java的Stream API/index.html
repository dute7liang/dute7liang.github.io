<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java,Spring,Maven,SpringBoot,Dubbo"><meta name="keywords" content="Java,Spring,Maven,SpringBoot,Dubbo"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>Stream API的操作 | duteliang</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Stream API的操作</h1><a id="logo" href="/.">duteliang</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Stream API的操作</h1><div class="post-meta"><a href="/2020/03/12/javabase/java%E7%9A%84Stream%20API/#comments" class="comment-count"></a><p><span class="date">Mar 12, 2020</span><span><a href="/categories/Java%E5%9F%BA%E7%A1%80/" class="category">Java基础</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="Stream-API的操作"><a href="#Stream-API的操作" class="headerlink" title="Stream API的操作"></a>Stream API的操作</h1><h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>在使用的jdk8这些新的语法和API的时候，一直对Stream的操作，一直是边搜索边使用，还经常忘记其使用方式，现特别总结一下。</p>
<p>其实使用Stream有时候有类似于sql的思想，想着怎么过滤数据和转换数据，最后输出一个自己想要的格式即可。但是我们要先知道jdk提供了什么方法</p>
<p>Stream的API的使用，我们将其分为几个重点</p>
<h2 id="1-创建Stream"><a href="#1-创建Stream" class="headerlink" title="1. 创建Stream"></a>1. 创建Stream</h2><h3 id="1-1-Arrays-stream-Array-和-Stream-of-Array"><a href="#1-1-Arrays-stream-Array-和-Stream-of-Array" class="headerlink" title="1.1 Arrays.stream(Array) 和 Stream.of(Array)"></a>1.1 Arrays.stream(Array) 和 Stream.of(Array)</h3><p>这两个我个人认为都是将数组转为Stream，所以直接放在一起了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr  = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">55</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">Stream&lt;Integer&gt; stream = Stream.of(arr);</span><br></pre></td></tr></table></figure>

<h3 id="1-2-Collection-stream"><a href="#1-2-Collection-stream" class="headerlink" title="1.2 Collection.stream()"></a>1.2 Collection.stream()</h3><p>这是用的最多的转换方式，Collection的子类都可以直接使用<code>.stream()</code>来获取Stream</p>
<h3 id="1-3-Stream-generate"><a href="#1-3-Stream-generate" class="headerlink" title="1.3 Stream.generate()"></a>1.3 Stream.generate()</h3><p>Stream.generate() 可以传入一个参数函数，用的倒是不多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.generate(() -&gt; <span class="string">"test"</span>).limit(<span class="number">3</span>);</span><br><span class="line">String[] strArr = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">System.out.println(Arrays.toString(strArr));</span><br></pre></td></tr></table></figure>

<h2 id="2-Stream的转换"><a href="#2-Stream的转换" class="headerlink" title="2. Stream的转换"></a>2. Stream的转换</h2><p>Stream的转换主要是将Stream转换成一个新的Stream。</p>
<h3 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h3><p>从名字可以看到实际就是一个Stream的过滤转换，可以变成一个新的Stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(a).filter(d -&gt; d &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="2-2-map-和-flatMap"><a href="#2-2-map-和-flatMap" class="headerlink" title="2.2 map 和 flatMap"></a>2.2 map 和 flatMap</h3><p><code>map</code>方法其主要是转换Stream的类型，同样传入一个参数函数，需要传递一个转换的函数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里从Integer的Stream 转换成了String类型</span></span><br><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; objectStream = Stream.of(a).map(i -&gt; String.valueOf(i));</span><br></pre></td></tr></table></figure>

<p><code>flatMap</code>方法主要是将多个Stream的合并操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">Integer[] b = <span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>&#125;;</span><br><span class="line">List&lt;Integer[]&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arr.add(a);</span><br><span class="line">arr.add(b);</span><br><span class="line"><span class="comment">// 多个Stream转为一个</span></span><br><span class="line">List&lt;Integer&gt; collect = arr.stream().flatMap(i -&gt; Arrays.stream(i)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="2-3-limit方法和skip方法"><a href="#2-3-limit方法和skip方法" class="headerlink" title="2.3 limit方法和skip方法"></a>2.3 limit方法和skip方法</h3><p>这两个比较好理解</p>
<p>limit方法就是截取前n个元素的流，若长度不够则返回原始流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(a).limit(<span class="number">20</span>).collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>skip方法和limit相反，就是丢弃前n个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(a).limit(<span class="number">4</span>).collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-distinct方法和sorted方法"><a href="#2-4-distinct方法和sorted方法" class="headerlink" title="2.4 distinct方法和sorted方法"></a>2.4 distinct方法和sorted方法</h3><p>distinct好理解，和sql的数据类似，其实就是去除重复的，如果是实体需要注意重写<code>equals</code>和<code>hashCode</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(a).distinct().collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>sorted也比较好理解，就是对流进行排序,和<code>Collections.sort()</code>有点类似</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; collect = Stream.of(a).sorted().collect(Collectors.toList());</span><br><span class="line">collect.forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h2 id="3-聚合操作"><a href="#3-聚合操作" class="headerlink" title="3. 聚合操作"></a>3. 聚合操作</h2><p>Stream的聚合就是将Stream汇聚和计算出一个具体的数值，比如最大值、最小值、总数等。这部分相对比较好理解</p>
<h3 id="3-1-min、max、count"><a href="#3-1-min、max、count" class="headerlink" title="3.1 min、max、count"></a>3.1 min、max、count</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">Integer min = Stream.of(a).min(Integer::compareTo).get();</span><br><span class="line">Integer max = Stream.of(a).max(Integer::compareTo).get();</span><br><span class="line"><span class="keyword">long</span> count = Stream.of(a).count();</span><br></pre></td></tr></table></figure>

<h3 id="3-2-findFirst-和-findAny"><a href="#3-2-findFirst-和-findAny" class="headerlink" title="3.2 findFirst 和 findAny"></a>3.2 findFirst 和 findAny</h3><p>获取第一个元素，我们可以用过fiter来获取第一个满足条件的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">Integer integer = Stream.of(a).filter(i -&gt; i &gt; <span class="number">3</span>).findFirst().get();</span><br><span class="line">System.out.println(integer);</span><br></pre></td></tr></table></figure>

<p>findAny 主要是在并行stream中使用，<code>parallelStream</code>的时候常用，这里不做例子了。</p>
<h3 id="3-3-anyMatch、-allMatch、noneMatch"><a href="#3-3-anyMatch、-allMatch、noneMatch" class="headerlink" title="3.3 anyMatch、 allMatch、noneMatch"></a>3.3 anyMatch、 allMatch、noneMatch</h3><p>anyMatch 可以判断流中是否有匹配的数据，然后返回boolean</p>
<p>allMatch 判断所有元素是否匹配</p>
<p>noneMatch 判断没有元素匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> boo = Stream.of(a).anyMatch(i -&gt; i == <span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-reduce"><a href="#3-4-reduce" class="headerlink" title="3.4 reduce"></a>3.4 reduce</h3><p>reduce 算是用的比较多的，可以将流中数据进行深沉次的计算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line">Integer integer = Stream.of(a).reduce((x, y) -&gt; x + y).get();</span><br><span class="line">System.out.println(integer);</span><br><span class="line"><span class="comment">// 带有初始化的求和</span></span><br><span class="line">integer = Stream.of(a).reduce(<span class="number">2</span>,(x, y) -&gt; x + y);</span><br><span class="line">System.out.println(integer);</span><br></pre></td></tr></table></figure>

<h2 id="4-收集输出操作"><a href="#4-收集输出操作" class="headerlink" title="4. 收集输出操作"></a>4. 收集输出操作</h2><p>我们将list转换成stream后，不会总是聚合操作，大部分我们还是返回一个集合回来，所以有了这一步的收集操作。将Stream重新变成一个Collection来便于我们使用</p>
<h3 id="4-1-集合输出"><a href="#4-1-集合输出" class="headerlink" title="4.1 集合输出"></a>4.1 集合输出</h3><p>集合输出还比较简单，常规的有 list、Set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; array = Stream.of(a).collect(Collectors.toList());</span><br><span class="line">List&lt;Integer&gt; array1 = Stream.of(a).collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">Set&lt;Integer&gt; hashSet = Stream.of(a).collect(Collectors.toSet());</span><br><span class="line">Set&lt;Integer&gt; hashSet1 = Stream.of(a).collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<h3 id="4-2-输出到map"><a href="#4-2-输出到map" class="headerlink" title="4.2 输出到map"></a>4.2 输出到map</h3><p>输出到map。经常是范型是一个对象的时候使用，也是非常常用的写法</p>
<p>先来创建和一个简单示例例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># NameMode 实际就是一个对象而已，不在贴出</span><br><span class="line">List&lt;NameModel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> NameModel(<span class="string">"23"</span>,<span class="number">2</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> NameModel(<span class="string">"das"</span>,<span class="number">3</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> NameModel(<span class="string">"eqw"</span>,<span class="number">4</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> NameModel(<span class="string">"fw"</span>,<span class="number">5</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> NameModel(<span class="string">"fw3123"</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<p>key和value都是具体的字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; collect =</span><br><span class="line">    list.stream().collect(Collectors.toMap(NameModel::getName, NameModel::getName));</span><br></pre></td></tr></table></figure>

<p>key是具体的字段，value为实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, NameModel&gt; collect =</span><br><span class="line">    list.stream().collect(Collectors.toMap(NameModel::getName, Function.identity()));</span><br></pre></td></tr></table></figure>

<p>还有一种情况是当key值重复多的时候。会出现异常。系统无法通过key值来获取唯一的value。这时候就会有第三个参数来处理了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里会报错</span></span><br><span class="line">Map&lt;Integer, String&gt; collect =</span><br><span class="line">    list.stream().collect(Collectors.toMap(NameModel::getAge, NameModel::getName));</span><br><span class="line"><span class="comment">// 通过第三个参数来解决</span></span><br><span class="line">Map&lt;Integer, String&gt; collect =</span><br><span class="line">            list.stream().collect(</span><br><span class="line">                Collectors.toMap(</span><br><span class="line">                    NameModel::getAge, </span><br><span class="line">                    NameModel::getName,</span><br><span class="line">                    <span class="comment">// 随便返回一个参数了</span></span><br><span class="line">                    (newValue,oldValue) -&gt; &#123;</span><br><span class="line">                        <span class="keyword">return</span> newValue; </span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="comment">// 这里也可以返回指定的map</span></span><br><span class="line">                    TreeMap::<span class="keyword">new</span></span><br><span class="line">            ));</span><br></pre></td></tr></table></figure>

<h3 id="4-3-分组输出"><a href="#4-3-分组输出" class="headerlink" title="4.3 分组输出"></a>4.3 分组输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 age 来映射多个集合</span></span><br><span class="line">Map&lt;Integer, List&lt;NameModel&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(NameModel::getAge));</span><br><span class="line"><span class="comment">// 分组的衍生，返回分组后的数量</span></span><br><span class="line">Map&lt;Integer, Long&gt; collect = list.stream().collect(Collectors.groupingBy(NameModel::getAge, Collectors.counting()));</span><br></pre></td></tr></table></figure>

<h3 id="4-4-拼接字符"><a href="#4-4-拼接字符" class="headerlink" title="4.4 拼接字符"></a>4.4 拼接字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">342</span>,<span class="number">13</span>,<span class="number">21</span>,<span class="number">4</span>,<span class="number">14</span>,<span class="number">23431</span>&#125;;</span><br><span class="line">String str = Stream.of(arr).map(String::valueOf).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<h2 id="5-分组"><a href="#5-分组" class="headerlink" title="5. 分组"></a>5. 分组</h2><p>我们可以把它想象成sql中的group by操作,就好理解很多了</p>
<h3 id="5-1-groupingBy"><a href="#5-1-groupingBy" class="headerlink" title="5.1 groupingBy"></a>5.1 groupingBy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分组后的数据</span></span><br><span class="line">Map&lt;Integer, List&lt;NameModel&gt;&gt; map =</span><br><span class="line">                list.stream().collect(Collectors.groupingBy(NameModel::getAge));</span><br><span class="line"><span class="comment">// 分组后求分组的count</span></span><br><span class="line">Map&lt;Integer, Long&gt; count =</span><br><span class="line">        list.stream().collect(Collectors.groupingBy(NameModel::getAge, Collectors.counting()));</span><br><span class="line"><span class="comment">// 分组后 求和</span></span><br><span class="line">Map&lt;String, Integer&gt; sum =</span><br><span class="line">        list.stream().collect(Collectors.groupingBy(NameModel::getName, Collectors.summingInt(NameModel::getAge)));</span><br><span class="line"><span class="comment">// 分组后 获取最大的一条数据， MinBy 可以获取最好的一条</span></span><br><span class="line">Map&lt;String, Optional&lt;NameModel&gt;&gt; maxBy =</span><br><span class="line">        list.stream().collect(Collectors.groupingBy(NameModel::getName,</span><br><span class="line">        Collectors.maxBy(Comparator.comparing(NameModel::getAge))));</span><br></pre></td></tr></table></figure>

<p>上部分的操作其实和sql分组思想都是类似。毕竟我们想要的数据变化方式一般也就这些</p>
<p>也可以支持多级分组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以无限套娃，自己去试试吧</span></span><br><span class="line">Map&lt;String, Map&lt;Integer, List&lt;NameModel&gt;&gt;&gt; collect = </span><br><span class="line">   list.stream().collect(Collectors.groupingBy(NameModel::getName, Collectors.groupingBy(NameModel::getAge)));</span><br></pre></td></tr></table></figure>

<h3 id="5-2-partitioningBy"><a href="#5-2-partitioningBy" class="headerlink" title="5.2 partitioningBy"></a>5.2 partitioningBy</h3><p><code>partitioningBy</code>主要是获取boolean类型的两组数据。当然对分组后的数据进行各种求和，求max操作都是和groupBy一样支持的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;NameModel&gt;&gt; collect = </span><br><span class="line">                list.stream().collect(Collectors.partitioningBy(nameModel -&gt; nameModel.getAge() == <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h2 id="6-并行操作"><a href="#6-并行操作" class="headerlink" title="6. 并行操作"></a>6. 并行操作</h2><p>并行流在stream的操作上还是比较好操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(roomList).parallel();</span><br></pre></td></tr></table></figure>

<p>直接使用其代码转换一下Stream流即可，但是注意后面的操作都是并行，需要注意并发安全。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: duteliang</p><p>原文链接: <a href="http://yoursite.com/2020/03/12/javabase/java的Stream API/">http://yoursite.com/2020/03/12/javabase/java的Stream API/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/jdk8-Stream/">jdk8,Stream</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2020/01/15/framework/aop%E8%AF%A6%E8%A7%A3/" class="next">AOP详解</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'e66ccfd3cc0f988a43f7',
  clientSecret: 'd9cf0716cfc050819353e4424522261ef119d283',
  repo: 'gittalk',
  owner: 'dute7liang',
  admin: ['dute7liang'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream-API的操作"><span class="toc-text">Stream API的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前沿"><span class="toc-text">前沿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-创建Stream"><span class="toc-text">1. 创建Stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Arrays-stream-Array-和-Stream-of-Array"><span class="toc-text">1.1 Arrays.stream(Array) 和 Stream.of(Array)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Collection-stream"><span class="toc-text">1.2 Collection.stream()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Stream-generate"><span class="toc-text">1.3 Stream.generate()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Stream的转换"><span class="toc-text">2. Stream的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-filter"><span class="toc-text">2.1 filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-map-和-flatMap"><span class="toc-text">2.2 map 和 flatMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-limit方法和skip方法"><span class="toc-text">2.3 limit方法和skip方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-distinct方法和sorted方法"><span class="toc-text">2.4 distinct方法和sorted方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-聚合操作"><span class="toc-text">3. 聚合操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-min、max、count"><span class="toc-text">3.1 min、max、count</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-findFirst-和-findAny"><span class="toc-text">3.2 findFirst 和 findAny</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-anyMatch、-allMatch、noneMatch"><span class="toc-text">3.3 anyMatch、 allMatch、noneMatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-reduce"><span class="toc-text">3.4 reduce</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-收集输出操作"><span class="toc-text">4. 收集输出操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-集合输出"><span class="toc-text">4.1 集合输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-输出到map"><span class="toc-text">4.2 输出到map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-分组输出"><span class="toc-text">4.3 分组输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-拼接字符"><span class="toc-text">4.4 拼接字符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-分组"><span class="toc-text">5. 分组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-groupingBy"><span class="toc-text">5.1 groupingBy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-partitioningBy"><span class="toc-text">5.2 partitioningBy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-并行操作"><span class="toc-text">6. 并行操作</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/12/javabase/java%E7%9A%84Stream%20API/">Stream API的操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/framework/aop%E8%AF%A6%E8%A7%A3/">AOP详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/microservices/zookeeper/">ZooKeeper</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/framework/SpringBoot%E5%90%AF%E5%8A%A8/">SpringBoot启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/framework/SpringBoot%E6%89%93%E5%8C%85%E5%88%86%E7%A6%BB%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/">SpringBoot打包分离资源文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/framework/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Bean的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/javabase/J.U.C/">J.U.C</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/javabase/Servlet/">Servlet</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/javabase/HashMap/">HashMap</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A1%86%E6%9E%B6/">Java框架</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NoSql/">NoSql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15px;">分布式</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/Zip-Java/" style="font-size: 15px;">Zip,Java</a> <a href="/tags/SpringBoot-Maven/" style="font-size: 15px;">SpringBoot,Maven</a> <a href="/tags/SpringBoot-Spring/" style="font-size: 15px;">SpringBoot,Spring</a> <a href="/tags/Spring-Bean/" style="font-size: 15px;">Spring,Bean</a> <a href="/tags/SpringMVC-Spring/" style="font-size: 15px;">SpringMVC,Spring</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/JavaEE-Servlet/" style="font-size: 15px;">JavaEE,Servlet</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/Spring-AOP-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">Spring,AOP,代理模式</a> <a href="/tags/jdk8-Stream/" style="font-size: 15px;">jdk8,Stream</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">duteliang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p><p><span><a rel="nofollwo" target="_blank" href="http://www.beian.miit.gov.cn/">粤ICP备19028616号</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>