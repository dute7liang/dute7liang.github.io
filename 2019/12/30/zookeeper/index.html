<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> ZooKeeper · duteliang</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="ZooKeeper - duteliang"><meta name="keywords" content=""><meta name="author" content="duteliang"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="duteliang"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="duteliang" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">ZooKeeper</h1><div class="post-info">2019-12-30<p class="visit"><i data-identity="2019/12/30/zookeeper/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h1 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在现在分布式、微服务大行其道的今天，肯定都会接触ZooKeeper这个框架。本人也只是在Dubbo的项目中有使用过(当然Kafka的集群部署也是基于ZooKeeper,这个就不算使用了)。但是它可以做的事远不止在Dubbo中的使用。所以先了解了ZooKeeper的基本模型、概念以及使用，以便加深学习</p>
<h2 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h2><p>ZooKeeper 是一个开源的分布式协调服务,设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p>
<p>ZooKeeper 是一个典型的分布式数据一致性解决方案。其主要应用场景：</p>
<ol>
<li>master节点选举，主节点挂了以后，从节点就会接收工作，并且节点是唯一的。保证高可用（比如Kafka集群）</li>
<li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他服务器。</li>
<li>发布与订阅。类似于消息队列MQ，dubbo发布者把数据发布到znode上，订阅者会拉出数据</li>
<li>分布式锁</li>
<li>集群管理，集群中保证数据的强一致性（Dubbo的注册中心）</li>
</ol>
<p>本人主要接触ZooKeeper还是在公司使用Dubbo的时候接触的，所以ZooKeeper主要是用于：服务的容错、负载均衡、查找服务和管理服务，还可以选择其作为配置中心的集中式管理。</p>
<h2 id="ZooKeeper的数据模型"><a href="#ZooKeeper的数据模型" class="headerlink" title="ZooKeeper的数据模型"></a>ZooKeeper的数据模型</h2><h3 id="Session机制"><a href="#Session机制" class="headerlink" title="Session机制"></a>Session机制</h3><p>在了解ZooKeeper的数据模型之前，有必要了解ZooKeeper的Session机制</p>
<p>Session是指客户端和服务端之间会话。在ZooKeeper中是指一个客户端与ZooKeeper之间的一次长连接。客户端在启动时会与服务端建立一个Tcp连接。后续客户端可已通过这个连接发送消息给服务端，也可以监听服务端发送来的消息。客户端和服务端有一个心跳机制来维持和判断这个连接的有效性，可以通过Session中的<code>sessionTimeout</code>值来设置一个客户端的超时时间。同时当由于服务器原因或者客户端主动要求端口连接的时候，只要在超时时间内重新连接任一一台ZooKeeper机器，那么之前创建的 Session仍然有效。</p>
<p>和我们平常接触到HttpSession一样，每次创建一次会话，服务端都会为该客户端分配一个SessionId，该SessionId也是全局唯一的。</p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>ZooKeeper的数据模型和我们经常使用的Unix/Linux的文件系统是类似的。</p>
<p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/ZooKeeper-model-cbdsiaaaa2312y7r671f7f376ghucdvq793f271.jpg" alt="ZooKeepr的内存模型"></p>
<p>上图中我们可以比较明显看到和文件系统很像，实际它提供的操作API都有点类似。正确情况下，我们会在会根目录下创建一个自己项目的Znode。比如dubbo、kafka以便隔离数据。和我们创建文件夹的思路一样</p>
<h4 id="znode"><a href="#znode" class="headerlink" title="znode"></a>znode</h4><ul>
<li>在ZooKeeper中每一个节点都称之为znode，它本身可以有子节点，也可以有数据。</li>
<li>每一个节点分为临时节点和永久节点，临时节点在客户端断开后消失。也就是Session超时</li>
<li>每一个节点都有各自的版本号。可以通过命令行来显示节点信息</li>
<li>没当节点的数据发生改变，那么该节点的版本号都会累加（乐观锁）</li>
<li>删除、修改节点时，如果版本号不匹配会报错（乐观锁）</li>
<li>由于ZooKeeper的数据都存在内存中，每个节点的数据不建议存储过大的数据。几K即可</li>
<li>节点也可以设置acl权限。可以通过权限来限制用户的操作（unix的文件权限）</li>
</ul>
<p>这里需要注意znode分为临时节点和永久节点，临时节点在session关闭时会自动删除</p>
<h4 id="watch机制"><a href="#watch机制" class="headerlink" title="watch机制"></a>watch机制</h4><p>ZooKeeper在针对每个节点的操作，都会有监督者（watcher），当监控对象znode发生了变化，则触发watcher事件，可以理解为监听器。zk中的watcher是一次性的，触发后立即销毁</p>
<p>父节点、子节点 增删改都能够触发watcher事件。 具体的watcher事件</p>
<ol>
<li>创建节点触发， NodeCreated</li>
<li>修改节点触发，NodeDataChanged</li>
<li>删除节点触发，NodeDeleted</li>
<li>增加子节点触发，NodeChildrenChanged</li>
<li>删除子节点触发，NodeChildrenChanged</li>
<li>修改子节点不触发监听</li>
</ol>
<blockquote>
<p>这里我建议自己在命令行或者用代码api来自己体验下</p>
</blockquote>
<h2 id="ZooKeeper命令行"><a href="#ZooKeeper命令行" class="headerlink" title="ZooKeeper命令行"></a>ZooKeeper命令行</h2><p>了解基本的命令行，其实ZooKeeper的命令行并不多，这里只做简单介绍</p>
<p>执行<code>./zkCli.sh</code>即可打开命令行</p>
<h3 id="查询命令"><a href="#查询命令" class="headerlink" title="查询命令"></a>查询命令</h3><p>ls path [watch] 查询目录</p>
<p>watch 设置子节点的watch事件</p>
<p>stat path [watch] 查询详细信息</p>
<p>watch 设置当前节点的watch事件（下面的watch都是类似的机制不在说明）</p>
<p>节点信息如下：</p>
<ul>
<li>cZxid 创建的id</li>
<li>ctime 创建的时间</li>
<li>mZxid 修改的id</li>
<li>mtime 修改的时间</li>
<li>pZxid 父节点的id</li>
<li>cversion 子节点的version</li>
<li>dataVersion 数据的version</li>
<li>aclVersion  权限的version</li>
<li>ephemeraOwner 0x0为永久节点，其他为临时节点（待定）</li>
<li>datalength 数据长度</li>
<li>numChildren 子节点的大小</li>
</ul>
<blockquote>
<p>zxid:ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生<br>创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p>
</blockquote>
<p>ls2 path [watch] 查询目录,同时展示节点的信息</p>
<p>get path [watch] 可以将目录的数据取出来</p>
<h3 id="创建命令"><a href="#创建命令" class="headerlink" title="创建命令"></a>创建命令</h3><p>create [-s] [-e] path data acl</p>
<p>-e 临时节点<br>-s 顺序节点 在创建文件夹会在后面自动添加1开始的顺序</p>
<p>create /test/name hello-world</p>
<h3 id="修改命令"><a href="#修改命令" class="headerlink" title="修改命令"></a>修改命令</h3><p>set path data [version]</p>
<p>version 主要用于更新时的乐观锁</p>
<h3 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h3><p>delete path [version]</p>
<p>version 主要用于删除时的乐观锁</p>
<h2 id="ZooKeeper的集群"><a href="#ZooKeeper的集群" class="headerlink" title="ZooKeeper的集群"></a>ZooKeeper的集群</h2><p>前面已经了解的ZooKeeper的概念，已经他能够为我们做什么。现在来了解一下ZooKeeper是怎么保证数据的统一性。以及自身集群的高可用。</p>
<h3 id="ZooKeeper-中的角色"><a href="#ZooKeeper-中的角色" class="headerlink" title="ZooKeeper 中的角色"></a>ZooKeeper 中的角色</h3><p>ZooKeeper在实际生产环境中是推荐使用集群方式。</p>
<p>在ZooKeeper的集群中引入了Leader、Follower、Observer三种角色。如下图所示</p>
<p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-cluster-12y789gcuh982gq.png" alt="ZooKeeper集群"></p>
<p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-cluster-12y789gcuh982gq.png" alt="ZooKeeper集群角色表"></p>
<p>ZooKeeper集群中的所有机器会通过Leader选举过程来选定一台成为Leader的机器。<br>该Leader既可以为客户端提供读服务和写服务，但是Follower和Observer都只能提供读服务。Follower和Observer的唯一区别就是不参与Leader的选举过程，Observer仅仅是用提升服务的读取速度而存在的。因为Follower的无限增多也会影响选举的性能。</p>
<p>ZooKeeper的核心是原子广播，这个机制保证各个Server之间的同步。实现这个机制的协议叫Zab协议。Zab协议有两种模式：恢复模式（选主）和广播模式（同步）  </p>
<p>当Leader服务器出现崩溃，重启，网络中断等异常情况时，Zab协议会进入恢复模式并选举出新的Leader服务  </p>
<p>大致步骤如下：</p>
<ol>
<li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。</li>
<li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。</li>
<li>Synchronization（同步阶段）:同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。同步完成之后 准 leader 才会成为真正的 leader。</li>
<li>Broadcast（广播阶段） 到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。</li>
</ol>
<blockquote>
<p>这里通过第一条的规则，所以ZooKeeper部署推荐为单数服务，假如3台机器。最大允许宕机一台。而四台机器也是最大允许宕机一台。所以并不推荐部署双数机器部署  </p>
</blockquote>
<h3 id="ZooKeeper的读写机制"><a href="#ZooKeeper的读写机制" class="headerlink" title="ZooKeeper的读写机制"></a>ZooKeeper的读写机制</h3><ul>
<li>Zookeeper是一个由多个server组成的集群</li>
<li>一个leader，多个follower</li>
<li>每个server保存一份数据副本</li>
<li>全局数据一致</li>
<li>分布式读写</li>
<li>更新请求转发，由leader实施</li>
</ul>
<h3 id="Zookeeper的保证"><a href="#Zookeeper的保证" class="headerlink" title="Zookeeper的保证"></a>Zookeeper的保证</h3><ul>
<li>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行</li>
<li>数据更新原子性，一次数据更新要么成功，要么失败</li>
<li>全局唯一数据视图，client无论连接到哪个server，数据视图都是一致的</li>
<li>实时性，在一定事件范围内，client能读到最新数据</li>
</ul>
<h3 id="Zookeeper的选举方式"><a href="#Zookeeper的选举方式" class="headerlink" title="Zookeeper的选举方式"></a>Zookeeper的选举方式</h3><p>首先选举必须要半数通过才行</p>
<p>简单模拟一下：</p>
<ul>
<li>A提案说，我要选自己，B你同意吗？C你同意吗？B说，我同意选A；C说，我同意选A。(注意，这里超过半数了，其实在现实世界选举已经成功了。但是计算机世界是很严格，另外要理解算法，要继续模拟下去。)</li>
<li>接着B提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；C说，A已经超半数同意当选，B提案无效。</li>
<li>接着C提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；B说，A已经超半数同意当选，C的提案无效。</li>
<li>选举已经产生了Leader，后面的都是follower，只能服从Leader的命令。而且这里还有个小细节，就是其实谁先启动谁当头。</li>
</ul>
<h3 id="Zab协议和Paxos算法"><a href="#Zab协议和Paxos算法" class="headerlink" title="Zab协议和Paxos算法"></a>Zab协议和Paxos算法</h3><p>Paxos算法应该可以说是ZooKeeper的灵魂了。但是ZooKeeper并没有完全采用Paxos算法 ，而是使用ZAB协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像Paxos算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<p>这里Paxos算法暂时没什么了解，可以参考一些文章和一些书籍了解</p>
<ul>
<li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">从Paxos到ZooKeeper</a></li>
<li><a href="http://codemacro.com/2014/10/15/explain-poxos/" target="_blank" rel="noopener">图解分布式一致性协议Paxos</a></li>
<li><a href="https://dbaplus.cn/news-141-1875-1.html" target="_blank" rel="noopener">实例详解ZooKeeper ZAB协议、分布式锁与领导选举</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>ZooKeeper本身就是一个分布式程序。超过半数以上存活，ZooKeeper就能正常服务</li>
<li>ZooKeeper的数据保存在内中，保证低延迟和高吞吐量，也不建议在znode中保存过大的数据</li>
<li>ZooKeeper推荐使用在读多写少的场景写，上面我们可以到了ZooKeeper只有leader才能执行写操作，这样做确实天然的保证的其顺序性，但是也影响了性能</li>
<li>znode有临时节点和永久节点的区分，临时节点在Session关闭时删除。（Session的关闭时通过Session超时来决定的，如果断开后再超时时间连上来Session是会继续维持）</li>
<li>ZooKeeper对于客户端主要提供两个操作：数据的增删改查和数据的监听服务</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/raphael5200/p/5285583.html" target="_blank" rel="noopener">https://www.cnblogs.com/raphael5200/p/5285583.html</a></li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2019 <a target="_blank">duteliang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="/scripts/ar-anchor.js"></script><script src="/scripts/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>