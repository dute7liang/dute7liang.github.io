<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Java,Spring,Maven,SpringBoot,Dubbo"><meta name="keywords" content="Java,Spring,Maven,SpringBoot,Dubbo"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>分布式锁 | duteliang</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">分布式锁</h1><a id="logo" href="/.">duteliang</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">分布式锁</h1><div class="post-meta"><a href="/2019/12/30/microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/#comments" class="comment-count"></a><p><span class="date">Dec 30, 2019</span><span><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" class="category">分布式</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式项目中必然而然的肯定会接触到分布式锁，相比诸如限流、熔断、分布式锁等其他技术。分布式锁在分布式项目是肯定会遇到的。因为其他技术可能在你的项目使用人数不多，业务简单而不需要。但是分布式锁在业务上基本是必须处理的。</p>
<p>目前分布式锁主流的实现方案有:redis分布式锁、ZooKeeper分布式锁两种。当然还有其他，比如基础关系型数据库来做分布式锁也有。这里只讲这两个。</p>
<h2 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h2><h3 id="基本原理-RedLock"><a href="#基本原理-RedLock" class="headerlink" title="基本原理-RedLock"></a>基本原理-RedLock</h3><p>redis分布式锁，在redis官方叫RedLock。其实现也主要分为两个阶段。</p>
<h4 id="加锁-RedLock"><a href="#加锁-RedLock" class="headerlink" title="加锁-RedLock"></a>加锁-RedLock</h4><p>redis中加锁主要通过set命令来解决其中还用到了<code>nx</code>和<code>px</code>参数(在redis2.6.12版本后set命令增加了很多新的参数，所以理论上setnx、setex、psetex会被set命令取代，后续也不推荐使用以上命令，可能后续版本会被不推荐或者移除，具体可查看官网)来控制。</p>
<p><code>SET key my_random_value NX PX 30000</code></p>
<p>比如通过以上命令就可以获取锁，由于NX的特性只有在key不存在时才能设置成功保证了锁的独占性，而PX则保证了在锁的安全性，避免获取锁的客户端在崩溃后，锁能够自然释放掉。其中<code>my_random_value</code>可以设置为一个随机值，必须保证该值得全局唯一性</p>
<h4 id="解锁-RedLock"><a href="#解锁-RedLock" class="headerlink" title="解锁-RedLock"></a>解锁-RedLock</h4><p>解锁的过程就可以直接使用DEL命令来解决，但是为了保证加锁和解锁是同一个客户端，所以我们要校验一下<code>my_random_value</code>是否正确。这里可以为了保证其原子性可以使用Lua脚本来完成</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>以上就是最基本的redis锁的原理</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>这种锁肯定也有缺点。在redis主从哨兵的环境中。比如我们在主服务器获取了锁。此时主服务宕机。由于redis主从复制的异步特性，该key值没有同步到从服务器。并且完成了选举，此时第二个客户端就可能直接在新的主服务器获取到锁。所以就可能存在两个客户端同时获取到锁。</p>
<p>所以我们在核心业务的逻辑处理中要自己去保证被加锁的代码块的幂等性，不会因为分布式锁的问题而导致出现核心业务受损。</p>
<blockquote>
<p>不知道有什么完美的解决方案，对redis内部的架构不大了解。待定！</p>
</blockquote>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson是redis的一个java客户端。也是redis官网推荐的客户端（Spring-data-redis默认使用的Jedis），其中Redisson也对redis的分布式锁进行封装处理。比如对其支持可重复锁，公平锁等扩张，以便我们更好的使用Redis分布式锁。来简单看下Redisson的内部源码实现</p>
<p>这里首先要特别注意下<strong>由于Redisson的版本更迭比较快，我发现锁的内部实现代码。每个版本都有一些差异。基本原理都是一样的</strong>我用的SpringBoot所以版本也都一样。</p>
<p>Redisson Version : 3.11.3<br>Redisson SpringBoot start Version ：3.11.3</p>
<h4 id="Redisson分布式锁的基本使用"><a href="#Redisson分布式锁的基本使用" class="headerlink" title="Redisson分布式锁的基本使用"></a>Redisson分布式锁的基本使用</h4><p>Redisson的分布式锁使用和Java中的<code>ReentrantLock</code>的使用是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">"myKey"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock(); <span class="comment">// 直接尝试获取锁</span></span><br><span class="line">        lock.tryLock(<span class="number">1</span>, TimeUnit.MINUTES); <span class="comment">// 也可以尝试获取锁 1分钟</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就是简单的lock使用。接下来来看下其源码实现</p>
<h4 id="获取lock"><a href="#获取lock" class="headerlink" title="获取lock"></a>获取lock</h4><p>首先在了解过<code>ReentrantLock</code>的实现上，在看其实现就会简单很多。</p>
<p>先看下<code>RLock lock = redissonClient.getLock(&quot;myKey&quot;);</code>这句主要做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RLock <span class="title">getLock</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RedissonLock(connectionManager.getCommandExecutor(), name); <span class="comment">// 构造函数在下面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedissonLock</span><span class="params">(CommandAsyncExecutor commandExecutor, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(commandExecutor, name);</span><br><span class="line">    <span class="comment">// 命令执行器</span></span><br><span class="line">    <span class="keyword">this</span>.commandExecutor = commandExecutor; </span><br><span class="line">    <span class="keyword">this</span>.id = commandExecutor.getConnectionManager().getId();</span><br><span class="line">    <span class="comment">// 内部锁过期时间 30000毫秒</span></span><br><span class="line">    <span class="keyword">this</span>.internalLockLeaseTime = commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout();</span><br><span class="line">    <span class="keyword">this</span>.entryName = id + <span class="string">":"</span> + name;</span><br><span class="line">    <span class="comment">// redis的发布订阅</span></span><br><span class="line">    <span class="keyword">this</span>.pubSub = commandExecutor.getConnectionManager().getSubscribeService().getLockPubSub();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Redisson加锁的实现"><a href="#Redisson加锁的实现" class="headerlink" title="Redisson加锁的实现"></a>Redisson加锁的实现</h4><p>构造函数没有特别的，主要是获取Redis的连接的基本类。和一些默认的参数</p>
<p>lock获取完了，接下来看第二部加锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> threadId = Thread.currentThread().getId(); <span class="comment">// 获取当前线程id</span></span><br><span class="line">    Long ttl = tryAcquire(leaseTime, unit, threadId); <span class="comment">// 尝试获取锁</span></span><br><span class="line">    <span class="comment">// 获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果获取锁失败，则订阅到对应这个锁的channel  TODO 这一步还没有仔细看，待定</span></span><br><span class="line">    RFuture&lt;RedissonLockEntry&gt; future = subscribe(threadId);</span><br><span class="line">    commandExecutor.syncSubscription(future);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ttl = tryAcquire(leaseTime, unit, threadId); <span class="comment">// 再次尝试获取锁</span></span><br><span class="line">            <span class="comment">// lock acquired</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 锁获取失败，等待ttl超时后再尝试获取</span></span><br><span class="line">            <span class="keyword">if</span> (ttl &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (interruptibly) &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquire();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    getEntry(threadId).getLatch().acquireUninterruptibly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 取消订阅</span></span><br><span class="line">        unsubscribe(future, threadId);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        get(lockAsync(leaseTime, unit));</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下跟下去详细看到尝试获取锁的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">RFuture&lt;Long&gt; <span class="title">tryAcquireAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123; <span class="comment">// 带有过期时间的获取锁</span></span><br><span class="line">        <span class="keyword">return</span> tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有带过期时间，则默认按30000毫秒来获取锁</span></span><br><span class="line">    RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    <span class="comment">// 如果没有获取到锁，则开启一个定时任务不断的去刷新该锁的过期时间 这里是一个看门狗的角色</span></span><br><span class="line">    ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lock acquired</span></span><br><span class="line">        <span class="keyword">if</span> (ttlRemaining == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleExpirationRenewal(threadId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着看tryLockInnerAsync方法</span></span><br><span class="line"><span class="comment">// 他使用了lua脚本来设置的，而且使用的Hash结构</span></span><br><span class="line">&lt;T&gt; <span class="function">RFuture&lt;T&gt; <span class="title">tryLockInnerAsync</span><span class="params">(<span class="keyword">long</span> leaseTime, TimeUnit unit, <span class="keyword">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> </span>&#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                <span class="comment">// 锁不存在 hset获取锁，同时设置过期时间</span></span><br><span class="line">                <span class="string">"if (redis.call('exists', KEYS[1]) == 0) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hset', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 锁已经存在  </span></span><br><span class="line">                <span class="comment">// 判断锁是否为当前线程，如果是对其值+1,同时再次设置时间(主要解决可重入锁的问题)</span></span><br><span class="line">                <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> +</span><br><span class="line">                    <span class="string">"redis.call('hincrby', KEYS[1], ARGV[2], 1); "</span> +</span><br><span class="line">                    <span class="string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> +</span><br><span class="line">                    <span class="string">"return nil; "</span> +</span><br><span class="line">                <span class="string">"end; "</span> +</span><br><span class="line">                <span class="comment">// 都不是则直接返回锁的ttl</span></span><br><span class="line">                <span class="string">"return redis.call('pttl', KEYS[1]);"</span>,</span><br><span class="line">                <span class="comment">// 下面是三个参数key[1] ARGV[1] ARGV[2] 分别是出传入key，时间，当前线程</span></span><br><span class="line">                <span class="comment">// 这里可以去简单了解下lua的调用语法即可</span></span><br><span class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在了解<code>key[1] ARGV[1] ARGV[2]</code>是什么后很简单了。</p>
<p>实际上他为了一个map结构的数据。</p>
<p>key - 锁的名称<br>filed - 随机字符串+线程ID 值为1<br>value - 线程ID 会随着的递增来实现可重入锁</p>
<p>加锁基本就已经完成！ 接着来看下解锁</p>
<h4 id="Redisson解锁的实现"><a href="#Redisson解锁的实现" class="headerlink" title="Redisson解锁的实现"></a>Redisson解锁的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title">unlockAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> RedissonPromise&lt;Void&gt;();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = unlockInnerAsync(threadId); <span class="comment">// 解锁的具体方法</span></span><br><span class="line"></span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 锁不存在异常 关闭前面开启的定时任务，抛出异常</span></span><br><span class="line">            cancelExpirationRenewal(threadId);</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁和持锁人不是同一个任务 抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (opStatus == <span class="keyword">null</span>) &#123;</span><br><span class="line">            IllegalMonitorStateException cause = <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"attempt to unlock lock, not locked by current thread by node id: "</span></span><br><span class="line">                    + id + <span class="string">" thread-id: "</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解锁成功 关闭前面开启的定时任务</span></span><br><span class="line">        cancelExpirationRenewal(threadId);</span><br><span class="line">        result.trySuccess(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接着直接看解锁的代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lua脚本</span></span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">            <span class="comment">// 1. 判断锁是否等于当前线程，不等于则返回</span></span><br><span class="line">            <span class="string">"if (redis.call('hexists', KEYS[1], ARGV[3]) == 0) then "</span> +</span><br><span class="line">                <span class="string">"return nil;"</span> +</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="comment">// 2. 对锁进行递减</span></span><br><span class="line">            <span class="string">"local counter = redis.call('hincrby', KEYS[1], ARGV[3], -1); "</span> +</span><br><span class="line">            <span class="comment">// &gt;0 则刷新一下过期时间</span></span><br><span class="line">            <span class="string">"if (counter &gt; 0) then "</span> +</span><br><span class="line">                <span class="string">"redis.call('pexpire', KEYS[1], ARGV[2]); "</span> +</span><br><span class="line">                <span class="string">"return 0; "</span> +</span><br><span class="line">            <span class="string">"else "</span> +</span><br><span class="line">            <span class="comment">// 不是则删除key，并同时发布锁释放的消息</span></span><br><span class="line">                <span class="string">"redis.call('del', KEYS[1]); "</span> +</span><br><span class="line">                <span class="string">"redis.call('publish', KEYS[2], ARGV[1]); "</span> +</span><br><span class="line">                <span class="string">"return 1; "</span>+</span><br><span class="line">            <span class="string">"end; "</span> +</span><br><span class="line">            <span class="string">"return nil;"</span>,</span><br><span class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redisson的加锁和解锁基本完成。只需要简单的记住它所维护的map数据结构即可很好的记住它的原理</p>
<h4 id="Redisson中的看门狗"><a href="#Redisson中的看门狗" class="headerlink" title="Redisson中的看门狗"></a>Redisson中的看门狗</h4><p>Redisson有一个看门狗的角色特别说明下，就是前面说的那个定时任务</p>
<p>首先通过前面的原理已经知道Redis在加锁的时候是会设置一下key的时间的。假如在持有锁的客户端在设置的时间内依然正在执行中，那么就很有可能锁被其他客户端拿到造成两个客户端同时获取到锁。为了解决这个问题才引入了看门狗这个角色。它主要监控获取锁的线程如果该线程一直在运行中，它可以为这个锁的时间来续约。默认是每次续约30000毫秒。</p>
<p>这个角色具体有兴趣可以自己看下源码。</p>
<h2 id="ZooKeeper分布式锁"><a href="#ZooKeeper分布式锁" class="headerlink" title="ZooKeeper分布式锁"></a>ZooKeeper分布式锁</h2><p>ZooKeeper的分布式锁首先我们要知道ZooKeeper的基本原理和内存模型。具体可以看我的另外一篇文章，这里不多做介绍了！</p>
<h3 id="基本原理-Zookeeper"><a href="#基本原理-Zookeeper" class="headerlink" title="基本原理-Zookeeper"></a>基本原理-Zookeeper</h3><h4 id="加锁-ZooKeeper"><a href="#加锁-ZooKeeper" class="headerlink" title="加锁-ZooKeeper"></a>加锁-ZooKeeper</h4><p>加锁主要是通过zookeeper来创建一个临时顺序节点。然后检查自己的节点是否为顺序中最小的那一个，如果不是则监听自己上一个顺序的节点等待被唤醒</p>
<p>实际就是类似维护了一个FIFO的队列，然后依次监听自己的上一个节点。就像链式结构一样</p>
<p>这里的临时节点可以保证，自己掉线后，由zookeeper来删除节点，最后通知下一个节点。保证链式不断。</p>
<h4 id="解锁-ZooKeeper"><a href="#解锁-ZooKeeper" class="headerlink" title="解锁-ZooKeeper"></a>解锁-ZooKeeper</h4><p>解锁就比较简单了。删除自己的节点即可。通过zookeeper的监听机制来通知其他节点</p>
<h3 id="Curator"><a href="#Curator" class="headerlink" title="Curator"></a>Curator</h3><p>既然Redis推荐Redisson，那么ZooKeeper肯定推荐的实现代码！这里推荐curator客户端。同时是基于ZooKeeper做一些开发。可推荐使用该客户端。因为原生客户端不大好用，比如由于ZooKeeper的watch绑定机制每次触发一次就会失效需要重新绑定。这里该客户端已经帮我们实现了动态绑定。避免我们写代码时忘记。详细使用可以自己查看官网了！</p>
<h4 id="Curator的基本使用"><a href="#Curator的基本使用" class="headerlink" title="Curator的基本使用"></a>Curator的基本使用</h4><p>这里用的版本是2.8.0，其他版本的源码可能有些许出入。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里简单看下使用的代码。非常简单。上面那部分代码可以集成在Spring中。统一使用<code>CuratorFramework</code>即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExponentialBackoffRetry retry = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework framework = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(<span class="string">"192.168.72.253:2181,192.168.72.253:2182,192.168.72.253:2183"</span>)</span><br><span class="line">        .sessionTimeoutMs(<span class="number">50000</span>)</span><br><span class="line">        .connectionTimeoutMs(<span class="number">50000</span>)</span><br><span class="line">        .retryPolicy(retry)</span><br><span class="line">        .namespace(<span class="string">"duteliang"</span>)</span><br><span class="line">        .build();</span><br><span class="line">framework.start();</span><br><span class="line"></span><br><span class="line">InterProcessMutex interProcessMutex = <span class="keyword">new</span> InterProcessMutex(framework,<span class="string">"/zl/lock/name"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    interProcessMutex.acquire(); <span class="comment">// 加锁</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    interProcessMutex.release(); <span class="comment">// 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Curator加锁的实现"><a href="#Curator加锁的实现" class="headerlink" title="Curator加锁的实现"></a>Curator加锁的实现</h4><p>简单看下<code>internalLock</code>的内部实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 查询缓存是否已经获取到锁了</span></span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="keyword">null</span> ) &#123; <span class="comment">// 已经获取到锁，可重入锁</span></span><br><span class="line">        lockData.lockCount.incrementAndGet(); <span class="comment">// lockCount +1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="keyword">null</span> )&#123;</span><br><span class="line">        <span class="comment">// 获取锁成功，添加缓存</span></span><br><span class="line">        LockData newLockData = <span class="keyword">new</span> LockData(currentThread, lockPath);</span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败 返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中重点就是<code>internals.attemptLock</code>获取锁这个方法！继续看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>      startMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> Long      millisToWait = (unit != <span class="keyword">null</span>) ? unit.toMillis(time) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="keyword">null</span>) ? <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">    <span class="keyword">int</span>             retryCount = <span class="number">0</span>;</span><br><span class="line">    String          ourPath = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         hasTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>         isDone = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> ( !isDone )&#123;</span><br><span class="line">        isDone = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 创建节点, 临时、顺序节点</span></span><br><span class="line">            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">            <span class="comment">// 判断是否获取锁，同时阻塞自己。关键部分</span></span><br><span class="line">            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">        &#125;<span class="keyword">catch</span> ( KeeperException.NoNodeException e )&#123;</span><br><span class="line">            <span class="keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )&#123;</span><br><span class="line">                isDone = <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( hasTheLock )&#123;</span><br><span class="line">        <span class="keyword">return</span> ourPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建节点, 临时、顺序节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String ourPath;</span><br><span class="line">    <span class="keyword">if</span> (lockNodeBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ourPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一步主要就是两步</p>
<ol>
<li>创建临时顺序节点</li>
<li>循环对顺序节点和自己进行检查，来判断自己是否可以获取锁</li>
</ol>
<p>接下来看第二部的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> doDelete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这一步是实现可撤销锁的动作，具体还没有研究</span></span><br><span class="line">        <span class="keyword">if</span> (revocable.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环获取锁</span></span><br><span class="line">        <span class="keyword">while</span> ((client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock) &#123;</span><br><span class="line">            List&lt;String&gt; children = getSortedChildren(); <span class="comment">// 获取所有顺序节点，注意已经排序好了。从小到大</span></span><br><span class="line">            String sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// 获取顺序节点的名称</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这一步就不贴源码了，可以自己看下比较简单</span></span><br><span class="line">            <span class="comment">// 主要判断当前节点是否为所有节点的第一个，如果是则获取到锁sTheLock=true, </span></span><br><span class="line">            <span class="comment">// 如果不是则获取到上一个顺序节点的名称</span></span><br><span class="line">            PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            <span class="keyword">if</span> (predicateResults.getsTheLock()) &#123; <span class="comment">// 获取到锁，返回</span></span><br><span class="line">                haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                String previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch(); <span class="comment">// 上一个顺序节点的完成名称</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 监听上一个节点、监听内代码在下面有贴。简单的notifyAll代码</span></span><br><span class="line">                        client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                        <span class="keyword">if</span> (millisToWait != <span class="keyword">null</span>) &#123; <span class="comment">// wait 开始阻塞线程等待</span></span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                            startMillis = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> (millisToWait &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                doDelete = <span class="keyword">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            wait(millisToWait);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">                        <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        doDelete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (doDelete) &#123; <span class="comment">// 如果出现程序异常，则删除自己的节点。</span></span><br><span class="line">            deleteOurPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haveTheLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里补充一下监听的代码。主要做了什么。</span></span><br><span class="line"><span class="comment">// 主要通过 wait 和 notifyAll 的组合来处理</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyFromWatcher</span><span class="params">()</span></span>&#123;</span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，其主要逻辑</p>
<ol>
<li>获取所有顺序节点</li>
<li>判断自己是否为顺序中最小的那个节点，是就获取锁</li>
<li>不是则获取自己上一个节点，然后watch它。等待唤醒</li>
</ol>
<p>这里为了便于理解可以参考一下下面的逻辑图</p>
<p><img src="https://javal.oss-cn-shenzhen.aliyuncs.com/zookeeper/zookeeper-lock-asp.jpg" alt="zookeeper加锁流程图"></p>
<h4 id="Curator解锁的实现"><a href="#Curator解锁的实现" class="headerlink" title="Curator解锁的实现"></a>Curator解锁的实现</h4><p>解锁就是比较简单了。就是删除节点。不多介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     Thread currentThread = Thread.currentThread();</span><br><span class="line">    InterProcessMutex.LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> (lockData == <span class="keyword">null</span>) &#123; <span class="comment">// 当前没有获取到锁。解锁失败</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"You do not own the lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> newLockCount = lockData.lockCount.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (newLockCount &gt; <span class="number">0</span>) &#123; <span class="comment">// 解锁成功</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newLockCount &lt; <span class="number">0</span>) &#123; <span class="comment">// 小于0，程序不正常。抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Lock count has gone negative for lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 删除节点，触发监听器</span></span><br><span class="line">        internals.releaseLock(lockData.lockPath);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 删除缓存</span></span><br><span class="line">        threadData.remove(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里基本讲完了Redis和ZooKeeper分布式锁的原理和实现。当然了解原理后可以自己去滚轮子，但是要注意很多细节部分。推荐还是直接使用上面的框架。</p>
<p>那么Redis和ZooKeeper分布式锁，哪个好一点了。</p>
<p>我认为首先两者在性能上面都是完全能够在生产环境使用的，两者之间的主要区别在于：</p>
<ol>
<li>Redis分布式锁上面已经讲过在主从集群环境中，有一个缺点。就是有可能两个客户端同时获取到锁，ZooKeeper就不存在这种。这主要是两者设计理念所造成的。就是我们常说的CAP原则，ZooKeeper保证的是CP（容错性和一致性），而redis保证的是AP（容错性和可用性）。具体可以去了解一下CAP的设计原则。</li>
<li>ZooKeeper在锁等待时会阻塞线程，不需要通过循环来解决。这也是由于ZooKeeper天然提供watch机制所带来的好处</li>
<li>ZooKeeper由于CP所带来的强一致性，性能没有redis好，同时由于ZooKeeper的实现中频繁的删除添加节点也有影响。但是ZooKeeper并不慢，只是与Redis比较而言</li>
</ol>
<p>所以如果能使用ZooKeeper我还是推荐使用ZooKeeper，但是ZooKeeper在项目中很多时候是作为注册中心来使用（比如dubbo），如果你的项目没有使用ZooKeeper，那么也可以使用Redis来做分布式锁，毕竟大部分项目都会使用Redis来做缓存。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://redis.io/commands/set" target="_blank" rel="noopener">redis官网set命令说明</a><br><a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a><br><a href="https://www.jianshu.com/p/47fd7f86c848" target="_blank" rel="noopener">分布式锁之Redis实现</a><br><a href="http://curator.apache.org/curator-recipes/shared-reentrant-lock.html" target="_blank" rel="noopener">curator-lock-document</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: duteliang</p><p>原文链接: <a href="http://yoursite.com/2019/12/30/microservices/分布式锁/">http://yoursite.com/2019/12/30/microservices/分布式锁/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/12/30/microservices/zookeeper/" class="pre">ZooKeeper</a><a href="/2019/10/12/framework/SpringBoot%E5%90%AF%E5%8A%A8/" class="next">SpringBoot启动</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'e66ccfd3cc0f988a43f7',
  clientSecret: 'd9cf0716cfc050819353e4424522261ef119d283',
  repo: 'gittalk',
  owner: 'dute7liang',
  admin: ['dute7liang'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'zh-CN',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式锁"><span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis分布式锁"><span class="toc-text">redis分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理-RedLock"><span class="toc-text">基本原理-RedLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加锁-RedLock"><span class="toc-text">加锁-RedLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解锁-RedLock"><span class="toc-text">解锁-RedLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson"><span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson分布式锁的基本使用"><span class="toc-text">Redisson分布式锁的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取lock"><span class="toc-text">获取lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson加锁的实现"><span class="toc-text">Redisson加锁的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson解锁的实现"><span class="toc-text">Redisson解锁的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson中的看门狗"><span class="toc-text">Redisson中的看门狗</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZooKeeper分布式锁"><span class="toc-text">ZooKeeper分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本原理-Zookeeper"><span class="toc-text">基本原理-Zookeeper</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#加锁-ZooKeeper"><span class="toc-text">加锁-ZooKeeper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解锁-ZooKeeper"><span class="toc-text">解锁-ZooKeeper</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Curator"><span class="toc-text">Curator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Curator的基本使用"><span class="toc-text">Curator的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Curator加锁的实现"><span class="toc-text">Curator加锁的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Curator解锁的实现"><span class="toc-text">Curator解锁的实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文档"><span class="toc-text">参考文档</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/15/framework/aop%E8%AF%A6%E8%A7%A3/">AOP详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/microservices/zookeeper/">ZooKeeper</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/30/microservices/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/12/framework/SpringBoot%E5%90%AF%E5%8A%A8/">SpringBoot启动</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/framework/SpringBoot%E6%89%93%E5%8C%85%E5%88%86%E7%A6%BB%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6/">SpringBoot打包分离资源文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/framework/Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">Bean的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/20/javabase/J.U.C/">J.U.C</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/05/12/javabase/Servlet/">Servlet</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/25/javabase/HashMap/">HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/04/19/javabase/%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/">Java线程和线程池</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A1%86%E6%9E%B6/">Java框架</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NoSql/">NoSql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 15px;">分布式</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 15px;">并发</a> <a href="/tags/Zip-Java/" style="font-size: 15px;">Zip,Java</a> <a href="/tags/SpringBoot-Maven/" style="font-size: 15px;">SpringBoot,Maven</a> <a href="/tags/SpringBoot-Spring/" style="font-size: 15px;">SpringBoot,Spring</a> <a href="/tags/Spring-Bean/" style="font-size: 15px;">Spring,Bean</a> <a href="/tags/SpringMVC-Spring/" style="font-size: 15px;">SpringMVC,Spring</a> <a href="/tags/Map/" style="font-size: 15px;">Map</a> <a href="/tags/JavaEE-Servlet/" style="font-size: 15px;">JavaEE,Servlet</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/tags/Spring-AOP-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">Spring,AOP,代理模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">duteliang.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>